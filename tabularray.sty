%% % -*- coding: utf-8 -*-

\RequirePackage{expl3}
%\RequirePackage{xparse}

\ExplSyntaxOn

\NewDocumentEnvironment { tblr } { O{c} m +b }
  { \buildtblr { #1 } { #2 } { #3 } } { }

\cs_generate_variant:Nn \tl_if_blank:nTF { xTF }
\cs_generate_variant:Nn \prop_item:Nn { Ne }
\cs_generate_variant:Nn \regex_replace_all:NnN { NVN }
\cs_generate_variant:Nn \seq_map_indexed_inline:Nn { cn }
%\cs_generate_variant:Nn \seq_map_indexed_function:NN {cN}
%\cs_generate_variant:Nn \seq_set_split:Nnn { cnn }
\prg_generate_conditional_variant:Nnn \prop_if_in:Nn { c } { T }

\tl_new:N  \l_tblr_a_tl
\tl_new:N  \l_tblr_b_tl
\tl_new:N  \l_tblr_d_tl
\tl_new:N  \l_tblr_h_tl
\tl_new:N  \l_tblr_i_tl  % for row index
\tl_new:N  \l_tblr_j_tl  % for column index
\int_new:N \l_tblr_c_int % for column number
\int_new:N \l_tblr_r_int % for row number
\dim_new:N \l_tblr_d_dim % for row depth
\dim_new:N \l_tblr_h_dim % for row height
\dim_new:N \l_tblr_w_dim % for column width
\box_new:N \l_tblr_c_box % for cell box

\seq_new:N \l_tblr_lines_seq
\int_new:N \l_tblr_row_count_int
\int_new:N \l_tblr_col_count_int
\int_new:N \g_tblr_level_int % store table nesting level
\prop_new:c { g_tblr_cell_1_prop } % store table cell text of level 1
\prop_new:c { g_tblr_spec_1_prop } % store table specification of level 1

\cs_new_protected:Npn \tblr_prop_gput:nnn #1 #2 #3
  {
    \prop_gput:cnn
      { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 } { #3 }
  }
\cs_generate_variant:Nn \tblr_prop_gput:nnn { nnV, nxn, nxx }

\cs_new:Npn \tblr_prop_item:nn #1 #2
  {
    \prop_item:cn { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 }
  }
\cs_generate_variant:Nn \tblr_prop_item:nn { ne }

\cs_new_protected:Npn \tblr_prop_if_in:nnT #1
  { \prop_if_in:cnT { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } }
\cs_new_protected:Npn \tblr_prop_if_in:nnTF #1
  { \prop_if_in:cnTF { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } }
\prg_generate_conditional_variant:Nnn \tblr_prop_if_in:nn { nx } { T, TF }

\cs_new_protected:Npn \tblr_prop_log:n #1
  {
    \prop_log:c { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop }
  }

%% Read, split and build the table
\cs_new_protected:Npn \buildtblr #1 #2 #3
  {
    \int_gincr:N \g_tblr_level_int
    \prop_gclear_new:c { g_tblr_cell_ \int_use:N \g_tblr_level_int _prop }
    \prop_gclear_new:c { g_tblr_spec_ \int_use:N \g_tblr_level_int _prop }
    \int_zero:N \l_tblr_row_count_int
    \int_zero:N \l_tblr_col_count_int
    \tl_set:Nn \l_tblr_body_tl {#3}
    %\tl_log:N \l_tblr_body_tl
    \tblr_insert_braces:N { \l_tblr_body_tl }
    \seq_set_split:NnV \l_tmpa_seq { \\ } \l_tblr_body_tl
    %\seq_log:N \l_tmpa_seq
    \seq_clear:N \l_tblr_lines_seq
    \seq_map_inline:Nn \l_tmpa_seq
      {
        \bool_lazy_or:nnTF
          { \tl_if_head_eq_meaning_p:nN { ##1 } * }
          { \tl_if_head_eq_meaning_p:nN { ##1 } [ }
          { \seq_put_right:Nn \l_tblr_lines_seq { \tblr_newline_skip ##1 } }
          { \seq_put_right:Nn \l_tblr_lines_seq { ##1 } }
      }
    \int_set:Nn \l_tblr_row_count_int { \seq_count:N \l_tblr_lines_seq }
    %\seq_log:N \l_tblr_lines_seq
    \seq_map_indexed_function:NN \l_tblr_lines_seq \tblr_split_line:nn
    \tblr_prop_log:n { cell }
    \tblr_initial_table
    \tblr_parse_column_spec:n { #2 }
    \tblr_calculate_cell_size
    \tblr_build_whole:n { #1 }
    \int_gdecr:N \g_tblr_level_int
  }

%% Insert and remove braces for nesting environments inside cells
%% These make line split and cell split workable
%% We need to replace N times for N level nestings
\regex_const:Nn \c_tblr_insert_braces_regex
  {
    \c{begin} \cB\{ (\c[^BE].*) \cE\} (.*?) \c{end} \cB\{ (\c[^BE].*) \cE\}
  }
\tl_const:Nn \c_tblr_insert_braces_tl
  {
    \c{begin} \cB\{ \cB\{ \1 \cE\} \2 \c{end} \cE\} \cB\{ \3 \cE\}
  }
\regex_const:Nn \c_tblr_remove_braces_regex
  {
    \c{begin} \cB\{ \cB\{ (.*?) \c{end} \cE\}
  }
\tl_const:Nn \c_tblr_remove_braces_tl
  {
    \c{begin} \cB\{ \1 \c{end}
  }
\cs_new_protected:Npn \tblr_insert_braces:N #1
  {
    \regex_replace_all:NVN \c_tblr_insert_braces_regex \c_tblr_insert_braces_tl #1
    \regex_replace_all:NVN \c_tblr_insert_braces_regex \c_tblr_insert_braces_tl #1
  }
\cs_new_protected:Npn \tblr_remove_braces:n #1
  {
    \tl_set:Nn \l_tmpa_tl { #1 }
    \regex_replace_all:NVN \c_tblr_remove_braces_regex \c_tblr_remove_braces_tl \l_tmpa_tl
    \regex_replace_all:NVN \c_tblr_remove_braces_regex \c_tblr_remove_braces_tl \l_tmpa_tl
  }

%% Split table line and get all the cells as a sequence
\cs_new_protected:Npn \tblr_split_line:nn #1 #2
  {
    \seq_set_split:Nnn \l_tmpa_seq { & } { #2 }
    %\seq_log:N \l_tmpa_seq
    \int_zero:N \l_tblr_c_int
    \seq_map_indexed_inline:Nn \l_tmpa_seq
      {
        \tblr_remove_braces:n { ##2 }
        \tblr_prop_gput:nnV { cell } { ( #1, ##1 ) } \l_tmpa_tl
        \int_incr:N \l_tblr_c_int
      }
    \int_compare:nT { \l_tblr_c_int > \l_tblr_col_count_int }
      {
        \int_set_eq:NN \l_tblr_col_count_int \l_tblr_c_int
      }
  }

\cs_new_protected:Npn \tblr_initial_table
  {
    \tblr_initial_table_spec
    \tblr_initial_table_command
  }

\int_new:N \rownum
\int_new:N \colnum

\cs_new_protected:Npn \tblr_initial_table_spec
  {
    \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
      {
        \tblr_prop_gput:nxn
          { spec } { row[\l_tblr_i_tl] / rowsep-above } { 0.2em }
        \tblr_prop_gput:nxn
          { spec } { row[\l_tblr_i_tl] / rowsep-below } { 0.2em }
      }
    \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
      {
        \tblr_prop_gput:nxn
          { spec } { col[\l_tblr_j_tl] / colsep-left } { 0.6em }
        \tblr_prop_gput:nxn
          { spec } { col[\l_tblr_j_tl] / colsep-right } { 0.6em }
      }
  }

\NewDocumentCommand { \settblr } { m }
  { \tblr_setup:n { #1 } }

%% Setup the table
\cs_new_protected:Npn \tblr_setup:n #1
  {
    \keys_set:nn { tblr } { #1 }
  }

\keys_define:nn { tblr }
  {
    hline .code:n = \tblr_spec_hline:n{ #1 },
  }

%% Treat \\*[dimen] command
\NewDocumentCommand \tblr_newline_skip { s o }
  {
    \IfBooleanT { #1 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / pagebreak }
          { none }
      }
    \IfValueT { #2 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / extra-rowsep-below }
          { #2 }
      }
  }

\cs_new_protected:Npn \tblr_spec_hline:n #1
  {
    \tblr_prop_gput:nxx
      { spec }
      { hline[\int_use:N \rownum] / style }
      { solid }
  }

\cs_new_protected:Npn \tblr_initial_table_command
  {
    \cs_set_protected:Npn \hline
      { \tblr_setup:n { hline } }
  }

%% Parse column specification
\cs_new_protected:Npn \tblr_parse_column_spec:n #1
  {
    \group_begin:
    \int_zero:N \colnum
    \char_set_catcode_active:N Y
    \char_set_active_eq:Nc Y { tblr_column_type_ Y }
    \char_set_catcode_active:N |
    \char_set_active_eq:Nc | { tblr_column_type_ | }
    \tex_scantokens:D { #1 }
    \group_end:
  }

\exp_args:Nc \NewDocumentCommand { tblr_column_type_ Y } { O{} }
  {
    \int_incr:N \colnum
  }

\exp_args:Nc \NewDocumentCommand { tblr_column_type_ | } { O{} }
  {
    \tblr_prop_gput:nxx
      { spec }
      { vline[\int_eval:n {\colnum + 1}] / style }
      { solid }
  }

%% Calculate the width and height of every cell
\cs_new_protected:Npn \tblr_calculate_cell_size
  {
    %% We need these two counters in executing table commands inside cells
    \int_zero:N \rownum
    \int_zero:N \colnum
    \int_step_inline:nn { \l_tblr_row_count_int }
      {
        \int_incr:N \rownum
        \int_zero:N \colnum
        \int_step_inline:nn { \l_tblr_col_count_int }
          {
            \int_incr:N \colnum
            \tblr_get_cell_size
            \tblr_update_row_col_size
          }
      }
    %% remove the last row when it has only \hline
    \tl_set:Nx \l_tblr_h_tl
      {
        \tblr_prop_item:ne { spec } { row[\l_tblr_row_count_int] / natural-height }
      }
    \tl_set:Nx \l_tblr_d_tl
      {
        \tblr_prop_item:ne { spec } { row[\l_tblr_row_count_int] / natural-depth }
      }
    \bool_lazy_and:nnT
      { \dim_compare_p:nNn { \l_tmpb_tl } = { 0pt } }
      { \dim_compare_p:nNn { \l_tmpb_tl } = { 0pt } }
      { \int_decr:N \l_tblr_row_count_int }
    \tblr_prop_log:n {spec }
  }

%% Get natural dimensions of current cell
\cs_new_protected:Npn \tblr_get_cell_size
  {
    \hbox_set:Nn \l_tblr_c_box
      {
        \tblr_prop_item:ne { cell } { (\int_use:N \rownum, \int_use:N \colnum) }
      }
    \tblr_prop_gput:nxx
      { spec }
      { cell[\int_use:N \rownum][\int_use:N \colnum] / natural-width }
      { \dim_use:N \box_wd:N \l_tblr_c_box }
    \tblr_prop_gput:nxx
      { spec }
      { cell[\int_use:N \rownum][\int_use:N \colnum] / natural-height }
      { \dim_use:N \box_ht:N \l_tblr_c_box }
    \tblr_prop_gput:nxx
      { spec }
      { cell[\int_use:N \rownum][\int_use:N \colnum] / natural-depth }
      { \dim_use:N \box_dp:N \l_tblr_c_box }
  }

%% Update natural dimensions of current row and current column
\cs_new_protected:Npn \tblr_update_row_col_size
  {
    %% Update natural width for every column
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { col[\int_use:N \colnum] / natural-width } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      {
        \dim_compare_p:nNn
          { \dim_use:N \box_wd:N \l_tblr_c_box } > { \l_tmpb_tl }
      }
      {
        \tblr_prop_gput:nxx
          { spec }
          { col[\int_use:N \colnum]/ natural-width }
          { \dim_use:N \box_wd:N \l_tblr_c_box }
      }
    %% Update natural height for every row
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { row[\int_use:N \rownum] / natural-height } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      {
        \dim_compare_p:nNn
          { \dim_use:N \box_ht:N \l_tblr_c_box } > { \l_tmpb_tl }
      }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_use:N \rownum] / natural-height }
          { \dim_use:N \box_ht:N \l_tblr_c_box }
      }
    %% Update natural depth for every row
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { row[\int_use:N \rownum] / natural-depth } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      {
        \dim_compare_p:nNn
          { \dim_use:N \box_dp:N \l_tblr_c_box } > { \l_tmpb_tl }
      }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_use:N \rownum] / natural-depth }
          { \dim_use:N \box_dp:N \l_tblr_c_box }
      }
  }

%% Build the whole table
\cs_new_eq:NN \tlbr_vbox_t:n \tex_vtop:D
\cs_new_eq:NN \tlbr_vbox_c:n \tex_vcenter:D
\cs_new_eq:NN \tlbr_vbox_b:n \tex_vbox:D
\cs_new_protected:Npn \tblr_build_whole:n #1
  {
    \tex_hbox:D
      { $ \m@th \cs:w tlbr_vbox_ #1 :n \cs_end:
          {
            \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
              {
                \tblr_prop_if_in:nxTF { spec } { hline[\l_tblr_i_tl] / style }
                  { \hrule }
                  { \hrule height ~ 0pt } % remove lineskip between two rows
                \tblr_get_row_inner_height_depth:VNN
                  \l_tblr_i_tl \l_tblr_h_dim \l_tblr_d_dim
                \tex_hbox:D
                  {
                    \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
                      {
                        \tblr_prop_if_in:nxT { spec } { vline[\l_tblr_j_tl]/style }
                          {
                            \vrule height~\l_tblr_h_dim ~ depth~\l_tblr_d_dim
                          }
                        \tblr_build_cell:NN \l_tblr_i_tl \l_tblr_j_tl
                      }
                    \tblr_prop_if_in:nxT { spec }
                      { vline[\int_eval:n {\l_tblr_col_count_int + 1}] / style }
                      {
                        \vrule height~\l_tblr_h_dim ~ depth~\l_tblr_d_dim
                      }
                  }
              }
            \tblr_prop_if_in:nxT { spec }
              { hline[\int_eval:n {\l_tblr_row_count_int + 1}] / style }
              { \hrule }
          } $
      }
  }

\cs_new_protected:Npn \tblr_build_cell:NN #1 #2
  {
    \skip_horizontal:n
      { \tblr_prop_item:ne { spec } { col[#2] / colsep-left } }
    \hbox_set:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { cell } { (#1,#2) } }
    \box_set_wd:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { spec } { col[#2] / natural-width } }
    \box_set_ht:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { spec } { row[#1] / natural-height } }
    \box_set_dp:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { spec } { row[#1] / natural-depth } }
    \box_use:N \l_tblr_c_box
    \skip_horizontal:n
      { \tblr_prop_item:ne { spec } { col[#2] / colsep-right } }
  }

%% Read from table specifications and calculate inner height of row
%% inner height = rowsep above  + natural height
%% inner depth  = natural depth + rowsep below
%% #1: the row number, #2: inner height, #3: inner depth
\cs_new_protected:Npn \tblr_get_row_inner_height_depth:nNN #1 #2 #3
  {
    \tl_set:Nx \l_tblr_a
      { \tblr_prop_item:ne { spec } { row[#1] / rowsep-above } }
    \tl_set:Nx \l_tblr_h
      { \tblr_prop_item:ne { spec } { row[#1] / natural-height } }
    \tl_set:Nx \l_tblr_d
      { \tblr_prop_item:ne { spec } { row[#1] / natural-depth } }
    \tl_set:Nx \l_tblr_b
      { \tblr_prop_item:ne { spec } { row[#1] / rowsep-below } }
    \dim_set:Nn #2 { \l_tblr_a + \l_tblr_h}
    \dim_set:Nn #3 { \l_tblr_d + \l_tblr_b }
  }
\cs_generate_variant:Nn \tblr_get_row_inner_height_depth:nNN { V }

\ExplSyntaxOff

