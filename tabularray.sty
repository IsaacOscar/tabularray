%%% % -*- coding: utf-8 -*-
%%% ----------------------------------------------------------------------------
%%% Tabularray: Typeset tabulars and arrays with LaTeX3
%%% Author    : Jianrui Lyu <tolvjr@163.com>
%%% Repository: https://github.com/lvjr/tabularray
%%% License   : The LaTeX Project Public License 1.3
%%% ----------------------------------------------------------------------------

\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\ProvidesExplPackage{tabularray}{2021-03-22}{2021B}
  {Typeset tabulars and arrays with LaTeX3}

%\RequirePackage{xparse}

\ExplSyntaxOn

\NewDocumentEnvironment { tblr } { O{c} m +b }
  { \buildtblr { #1 } { #2 } { #3 } } { }

\cs_generate_variant:Nn \prop_item:Nn { Ne }
\cs_generate_variant:Nn \prop_put:Nnn { Nxn, Nxx }
\cs_generate_variant:Nn \regex_replace_all:NnN { NVN }
\cs_generate_variant:Nn \seq_map_indexed_inline:Nn { cn }
\cs_generate_variant:Nn \tl_gput_right:Nn { Nf }
\cs_generate_variant:Nn \tl_if_blank:nTF { xTF }
\prg_generate_conditional_variant:Nnn \prop_if_in:Nn { c } { T }

\tl_new:N  \l__tblr_a_tl
\tl_new:N  \l__tblr_b_tl
\tl_new:N  \l__tblr_c_tl
\tl_new:N  \l__tblr_d_tl
\tl_new:N  \l__tblr_h_tl
\tl_new:N  \l__tblr_i_tl  % for row index
\tl_new:N  \l__tblr_j_tl  % for column index
\tl_new:N  \l__tblr_v_tl
\tl_new:N  \l__tblr_w_tl
\int_new:N \l__tblr_c_int % for column number
\int_new:N \l__tblr_r_int % for row number
\dim_new:N \l__tblr_d_dim % for depth
\dim_new:N \l__tblr_h_dim % for height
\dim_new:N \l__tblr_w_dim % for width
\box_new:N \l__tblr_b_box
\box_new:N \l__tblr_c_box % for cell box

\int_new:N \g_tblr_level_int % store table nesting level
\prop_new:c { g_tblr_cell_1_prop } % store table cell text of level 1
\prop_new:c { g_tblr_spec_1_prop } % store table specification of level 1

\cs_new_protected:Npn \__tblr_prop_gput:nnn #1 #2 #3
  {
    \prop_gput:cnn
      { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 } { #3 }
  }
\cs_generate_variant:Nn \__tblr_prop_gput:nnn { nnx, nnV, nxn, nxx, nxV }

\cs_new:Npn \__tblr_prop_item:nn #1 #2
  {
    \prop_item:cn { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 }
  }
\cs_generate_variant:Nn \__tblr_prop_item:nn { ne }

\cs_new_protected:Npn \__tblr_prop_if_in:nnT #1
  {
    \prop_if_in:cnT { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop }
  }
\cs_new_protected:Npn \__tblr_prop_if_in:nnTF #1
  {
    \prop_if_in:cnTF { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop }
  }
\prg_generate_conditional_variant:Nnn \__tblr_prop_if_in:nn { nx } { T, TF }

\cs_new_protected:Npn \__tblr_prop_log:n #1
  {
    \prop_log:c { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop }
  }

%% Read, split and build the table

\cs_new_protected:Npn \buildtblr #1 #2 #3
  {
    \int_gincr:N \g_tblr_level_int
    \prop_gclear_new:c { g_tblr_cell_ \int_use:N \g_tblr_level_int _prop }
    \prop_gclear_new:c { g_tblr_spec_ \int_use:N \g_tblr_level_int _prop }
    \__tblr_enable_table_commands:
    \__tblr_split_table:n { #3 }
    \__tblr_initial_table_spec:
    \__tblr_parse_table_spec:n { #2 }
    \__tblr_calculate_cell_and_line_size:
    \__tblr_build_whole:n { #1 }
    \int_gdecr:N \g_tblr_level_int
  }

%% Insert and remove braces for nesting environments inside cells
%% These make line split and cell split workable
%% We need to replace N times for N level nestings
\regex_const:Nn \c__tblr_insert_braces_regex
  {
    \c{begin} \cB\{ (\c[^BE].*) \cE\} (.*?) \c{end} \cB\{ (\c[^BE].*) \cE\}
  }
\tl_const:Nn \c__tblr_insert_braces_tl
  {
    \c{begin} \cB\{ \cB\{ \1 \cE\} \2 \c{end} \cE\} \cB\{ \3 \cE\}
  }
\regex_const:Nn \c__tblr_remove_braces_regex
  {
    \c{begin} \cB\{ \cB\{ (.*?) \c{end} \cE\}
  }
\tl_const:Nn \c__tblr_remove_braces_tl
  {
    \c{begin} \cB\{ \1 \c{end}
  }
\cs_new_protected:Npn \__tblr_insert_braces:N #1
  {
    \regex_replace_all:NVN \c__tblr_insert_braces_regex \c__tblr_insert_braces_tl #1
    \regex_replace_all:NVN \c__tblr_insert_braces_regex \c__tblr_insert_braces_tl #1
  }
\cs_new_protected:Npn \__tblr_remove_braces:N #1
  {
    \regex_replace_all:NVN \c__tblr_remove_braces_regex \c__tblr_remove_braces_tl #1
    \regex_replace_all:NVN \c__tblr_remove_braces_regex \c__tblr_remove_braces_tl #1
  }

%% Split table content to cells and store them
%% #1: table content

\seq_new:N \l_tblr_lines_seq
\int_new:N \l_tblr_row_count_int
\int_new:N \l_tblr_col_count_int

\cs_new_protected:Npn \__tblr_split_table:n #1
  {
    \int_zero:N \l_tblr_row_count_int
    \int_zero:N \l_tblr_col_count_int
    \__tblr_split_table_to_lines:nN { #1 } \l_tblr_lines_seq
    \__tblr_split_lines_to_cells:N \l_tblr_lines_seq
  }

%% Split table content to a sequence of lines
%% #1: table content, #2: resulting sequence of lines
\cs_new_protected:Npn \__tblr_split_table_to_lines:nN #1 #2
  {
    \tl_set:Nn \l_tmpa_tl { #1 }
    \__tblr_insert_braces:N \l_tmpa_tl
    \seq_set_split:NnV \l_tmpa_seq { \\ } \l_tmpa_tl
    \seq_clear:N #2
    \seq_map_inline:Nn \l_tmpa_seq
      {
        \bool_lazy_or:nnTF
          { \tl_if_head_eq_meaning_p:nN { ##1 } * }
          { \tl_if_head_eq_meaning_p:nN { ##1 } [ }
          { \seq_put_right:Nn #2 { \__tblr_newline_skip:w ##1 } }
          { \seq_put_right:Nn #2 { ##1 } }
      }
    \int_set:Nn \l_tblr_row_count_int { \seq_count:N #2 }
  }

%% Split table lines to cells and store them
%% #1: sequence of lines
\cs_new_protected:Npn \__tblr_split_lines_to_cells:N #1
  {
    \seq_map_indexed_function:NN #1 \__tblr_split_one_line:nn
    \__tblr_prop_log:n { cell }
  }

%% Two counters for row and column numbering
\int_new:N \rownum
\int_new:N \colnum

%% Split one line into cells and store them
%% #1: row number, #2 the line text
\cs_new_protected:Npn \__tblr_split_one_line:nn #1 #2
  {
    \seq_set_split:Nnn \l_tmpa_seq { & } { #2 }
    \int_zero:N \l__tblr_c_int
    \seq_map_inline:Nn \l_tmpa_seq
      {
        \tl_set:Nn \l_tmpa_tl { ##1 }
        \__tblr_remove_braces:N \l_tmpa_tl
        \int_incr:N \l__tblr_c_int
        \__tblr_prop_gput:nxV { cell }
          { ( #1, \int_use:N \l__tblr_c_int ) } \l_tmpa_tl
        \__tblr_check_multicolumn_and_add_cell:nN { #1 } \l_tmpa_tl
      }
    %% Measure the last row with single cell and parse \hline at the same time
    %% Decrease row count by 1 when it's an empty cell (has only \hline)
    %% We need to do it here since the > or < column type may add text to cells
    \bool_set_false:N \l_tmpa_bool
    \int_compare:nNnT { \l__tblr_c_int } = { 1 }
      {
        \int_set:Nn \rownum { #1 }
        \int_set:Nn \colnum { 1 }
        \__tblr_measure_cell_size:nnNNN
          { #1 } { 1 } \l__tblr_w_dim \l__tblr_h_dim \l__tblr_d_dim
        \bool_lazy_and:nnT
          { \dim_compare_p:nNn { \l__tblr_h_dim } = { 0pt } }
          { \dim_compare_p:nNn { \l__tblr_d_dim } = { 0pt } }
          { \bool_set_true:N \l_tmpa_bool }
      }
    \bool_if:NTF \l_tmpa_bool
      { \int_decr:N \l_tblr_row_count_int }
      {
        \__tblr_prop_gput:nnx
          { spec } { row[#1] / cell-number } { \int_use:N \l__tblr_c_int }
        \int_compare:nT { \l__tblr_c_int > \l_tblr_col_count_int }
          {
            \int_set_eq:NN \l_tblr_col_count_int \l__tblr_c_int
          }
      }
  }

%% Find \multicolumn command and replace it with \MultiCell
%% We also need to add empty cells after the span cell
\cs_new_protected:Npn \__tblr_check_multicolumn_and_add_cell:nN #1 #2
  {
    \tl_set:Nx \l__tblr_a_tl { \tl_item:Nn #2 { -4 } }
    \tl_set:Nx \l__tblr_b_tl { \tl_item:Nn #2 { -3 } }
    \tl_if_eq:NnT \l__tblr_a_tl { \multicolumn }
      {
        \prg_replicate:nn { \l__tblr_b_tl - 1 }
          {
            \int_incr:N \l__tblr_c_int
            \__tblr_prop_gput:nxn { cell }
              { ( #1, \int_use:N \l__tblr_c_int ) } { }
          }
      }
  }

\prop_const_from_keyval:Nn \c_tblr_default_keyval_row_prop
  {
    rowsep-above   = 0.2em,
    rowsep-below   = 0.2em,
    content-height = 0pt,
    content-depth  = 0pt,
  }

\prop_const_from_keyval:Nn \c_tblr_default_keyval_col_prop
  {
    colsep-left    = 0.6em,
    colsep-right   = 0.6em,
    halign         = left,
    valign         = top,
    content-width  = 0pt,
  }

\prop_const_from_keyval:Nn \c_tblr_default_keyval_cell_prop
  {
    content-width  = 0pt,
    content-height = 0pt,
    content-depth  = 0pt,
  }

\cs_new_protected:Npn \__tblr_initial_table_spec:
  {
    \int_step_variable:nNn { \l_tblr_row_count_int } \l__tblr_i_tl
      {
        \prop_map_inline:Nn \c_tblr_default_keyval_row_prop
          {
            \__tblr_prop_gput:nxn { spec } { row[\l__tblr_i_tl] / ##1 } { ##2 }
          }
        \int_step_variable:nNn { \l_tblr_col_count_int } \l__tblr_j_tl
          {
            \prop_map_inline:Nn \c_tblr_default_keyval_cell_prop
              {
                \__tblr_prop_gput:nxn { spec }
                  { cell[\l__tblr_i_tl][\l__tblr_j_tl] / ##1 } { ##2 }
              }
          }
      }
    \int_step_variable:nNn { \l_tblr_col_count_int } \l__tblr_j_tl
      {
        \prop_map_inline:Nn \c_tblr_default_keyval_col_prop
          {
            \__tblr_prop_gput:nxn { spec } { col[\l__tblr_j_tl] / ##1 } { ##2 }
          }
      }
  }

\NewDocumentCommand { \settblr } { m }
  { \tblr_setup:n { #1 } }

%% Setup the table
\cs_new_protected:Npn \tblr_setup:n #1
  {
    \keys_set:nn { tblr } { #1 }
  }
\cs_generate_variant:Nn \tblr_setup:n { x }

%% If the key doesn't exist, create it ahead
\cs_new_protected:Npn \__tblr_keys_define_set:nn #1 #2
  {
    \keys_if_exist:nnF { tblr } { #1 }
      {
        \keys_define:nn { tblr }
          { #1 .code:n = \__tblr_keys_gput:nn { #1 } { ##1 } }
      }
    \keys_set:nn { tblr } { #1 = #2 }
  }
\cs_generate_variant:Nn \__tblr_keys_define_set:nn { xn, xx }

\cs_new_protected:Npn  \__tblr_keys_gput:nn #1 #2
  {
    \__tblr_prop_gput:nnn { spec } { #1 } { #2 }
  }
\cs_generate_variant:Nn \__tblr_keys_gput:nn { nx }

\keys_define:nn { tblr }
  {
    width .code:n = \__tblr_keys_gput:nx { width } { \dim_eval:n { #1 } },
    colspec .code:n = \__tblr_parse_column_spec:n { #1 },
    hline .code:n = \__tblr_spec_hline:n { #1 },
  }

%% Treat \\*[dimen] command
\NewDocumentCommand \__tblr_newline_skip:w { s o }
  {
    \IfBooleanT { #1 }
      {
        \__tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / pagebreak }
          { none }
      }
    \IfValueT { #2 }
      {
        \__tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / extra-rowsep-below }
          { #2 }
      }
  }

%% We need some commands to modify table/row/column/cell specifications.
%% These commands must be defined with \NewTableCommand command,
%% so that we are able to execute them once and then disable them.

\clist_new:N \g__tblr_table_commands_clist

\msg_new:nnn { tabularray } { defined-table-command }
  { Table ~ commnad ~ #1 has ~ been ~ defined! }

\NewDocumentCommand \NewTableCommand { m O{0} o m }
  {
    \clist_if_in:NnTF \g__tblr_table_commands_clist { #1 }
      {
        \msg_error:nnn { tabularray } { defined-table-command } { #1 }
        \clist_log:N \g__tblr_table_commands_clist
      }
      {
        \__tblr_make_xparse_arg_spec:nnN { #2 } { #3 } \l_tblr_a_tl
        \exp_args:NcV \NewDocumentCommand
          { __tblr_table_command_ \cs_to_str:N #1 :w } \l_tblr_a_tl { #4 }
        \exp_args:NcV \NewDocumentCommand
          { __tblr_table_command_ \cs_to_str:N #1 _gobble :w } \l_tblr_a_tl { }
        \clist_gput_right:Nn \g__tblr_table_commands_clist { #1 }
      }
  }

%% #1: argument number, #2: optional argument default, #3: result tl
\cs_new_protected:Npn \__tblr_make_xparse_arg_spec:nnN #1 #2 #3
  {
    \tl_clear:N #3
    \int_compare:nNnT { #1 } > { 0 }
      {
        \IfValueTF { #2 }
          { \tl_set:Nn #3 { O{#2} } }
          { \tl_set:Nn #3 { m } }
        \tl_put_right:Nx #3 { \prg_replicate:nn { #1 - 1 } { m } }
      }
  }

\cs_new_protected:Npn \__tblr_enable_table_commands:
  {
    \clist_map_inline:Nn \g__tblr_table_commands_clist
      { \cs_set_eq:Nc ##1 { __tblr_table_command_ \cs_to_str:N ##1 :w } }
  }

\cs_new_protected:Npn \__tblr_disable_table_commands:
  {
    \clist_map_inline:Nn \g__tblr_table_commands_clist
      { \cs_set_eq:Nc ##1 { __tblr_table_command_ \cs_to_str:N ##1 _gobble:w } }
  }

%% Add \hline command

\NewTableCommand \hline
  {
    \tblr_setup:n { hline }
  }

\cs_new_protected:Npn \__tblr_spec_hline:n #1
  {
    \__tblr_prop_gput:nxx
      { spec }
      { hline[\int_use:N \rownum] / style }
      { solid }
  }

%% Parse table specifications

\regex_const:Nn \c__tblr_long_key_name_regex { [A-Za-z]{3,} \s* = }

\cs_new_protected:Npn \__tblr_parse_table_spec:n #1
  {
    \regex_match:NnTF \c__tblr_long_key_name_regex { #1 }
      { \keys_set:nn { tblr } { #1 } }
      { \__tblr_parse_column_spec:n { #1 } }
  }

%% Some primitive column types

\str_const:Nn \c_tblr_primitive_column_types_str { Q | < > }
\tl_new:N \g_tblr_expanded_colspec_tl

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ Q } { O{} }
  {
    \int_incr:N \colnum
    \keys_set:nn { tblr-column-type-Q } { #1 }
    \__tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ Q } { O{} }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { Q[#1] }
    \__tblr_expand_column_spec_next:N
  }

\keys_define:nn { tblr-column-type-Q }
  {
    l .code:n = \__tblr_prop_gput:nxn { spec }
                  { col[\int_use:N \colnum] / halign } { left },
    c .code:n = \__tblr_prop_gput:nxn { spec }
                  { col[\int_use:N \colnum] / halign } { center },
    r .code:n = \__tblr_prop_gput:nxn { spec }
                  { col[\int_use:N \colnum] / halign } { right },
    t .code:n = \__tblr_prop_gput:nxn { spec }
                  { col[\int_use:N \colnum] / valign } { top },
    p .code:n = \__tblr_prop_gput:nxn { spec }
                  { col[\int_use:N \colnum] / valign } { top },
    m .code:n = \__tblr_prop_gput:nxn { spec }
                  { col[\int_use:N \colnum] / valign } { middle },
    b .code:n = \__tblr_prop_gput:nxn { spec }
                  { col[\int_use:N \colnum] / valign } { bottom },
    wd .code:n = \__tblr_prop_gput:nxx { spec }
                   { col[\int_use:N \colnum] / width } { \dim_eval:n {#1} },
    co .code:n = \__tblr_prop_gput:nxx { spec }
                   { col[\int_use:N \colnum] / coefficient } { \int_eval:n {#1} },
    unknown .code:n = \__tblr_column_type_Q_unknown_key:V \l_keys_key_str,
  }

\msg_new:nnn { tabularray } { column-type-Q-unknown-key }
  { Unknown ~ key ~ #1 ~ in ~ column ~ type ~ Q! }

\regex_const:Nn \c__tblr_is_number_key_regex { [\+\-]? \d+ }

\cs_new_protected:Npn \__tblr_column_type_Q_unknown_key:n #1
  {
    \regex_match:NnTF \c__tblr_is_number_key_regex { #1 }
      {
        \__tblr_prop_gput:nxx { spec }
          { col[\int_use:N \colnum] / coefficient } { #1 }
      }
      { \msg_warning:nnn { tabularray } { column-type-Q-unknown-key } { #1 } }
  }
\cs_generate_variant:Nn \__tblr_column_type_Q_unknown_key:n { V }

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ | } { O{} }
  {
    \tl_if_blank:nTF { #1 }
      { \keys_set:nn { tblr-column-type-| } { tt = \vrule } }
      { \keys_set:nn { tblr-column-type-| } { #1 } }
    \__tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ | } { O{} }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { |[#1] }
    \__tblr_expand_column_spec_next:N
  }

\keys_define:nn { tblr-column-type-| }
  {
    tt .code:n = \cs:w __tblr_column_type_|_set_vline_text:n \cs_end: { #1 },
    fg .code:n = \__tblr_prop_gput:nxn { spec }
                   { vline[\int_eval:n {\colnum + 1}] / foreground } { #1 },
    bg .code:n = \__tblr_prop_gput:nxn { spec }
                   { vline[\int_eval:n {\colnum + 1}] / background } { #1 },
  }

\cs_new_protected:cpn { __tblr_column_type_|_set_vline_text:n } #1
  {
    \int_step_inline:nn { \l_tblr_row_count_int }
      {
        \__tblr_prop_gput:nxn { spec }
          { vline[##1][\int_eval:n {\colnum + 1}] / text } { #1 }
      }
  }

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ > } { O{} m }
  {
    \tl_if_blank:nF { #1 }
      {
        \__tblr_prop_gput:nxx
          { spec }
          { col[\int_eval:n {\colnum + 1}] / colsep-left }
          { \dim_eval:n { #1 } }
      }
    \tl_if_blank:nF { #2 }
      {
        \int_step_variable:nNn { \l_tblr_row_count_int } \l__tblr_i_tl
          {
            \tl_set:Nx \l_tmpa_tl
            {
              \__tblr_prop_item:ne { cell }
                { (\l__tblr_i_tl,\int_eval:n {\colnum + 1}) }
            }
            \tl_put_left:Nn \l_tmpa_tl { #2 }
            \__tblr_prop_gput:nxV
              { cell }
              { (\l__tblr_i_tl,\int_eval:n {\colnum + 1}) }
              \l_tmpa_tl
          }
      }
    \__tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ > } { O{} m }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { >[#1]{#2} }
    \__tblr_expand_column_spec_next:N
  }

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ < } { O{} m }
  {
    \tl_if_blank:nF { #1 }
      {
        \__tblr_prop_gput:nxx
          { spec }
          { col[\int_use:N \colnum] / colsep-right }
          { \dim_eval:n { #1 } }
      }
    \tl_if_blank:nF { #2 }
      {
        \int_step_variable:nNn { \l_tblr_row_count_int } \l__tblr_i_tl
          {
            \tl_set:Nx \l_tmpa_tl
            {
              \__tblr_prop_item:ne { cell } { (\l__tblr_i_tl,\int_use:N \colnum) }
            }
            \tl_put_right:Nn \l_tmpa_tl { #2 }
            \__tblr_prop_gput:nxV
              { cell }
              { (\l__tblr_i_tl,\int_use:N \colnum) }
              \l_tmpa_tl
          }
      }
    \__tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ < } { O{} m }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { <[#1]{#2} }
    \__tblr_expand_column_spec_next:N
  }

%% \NewColumnType command and predefined column types

\str_new:N \g_tblr_used_column_types_str
\str_gset_eq:NN
  \g_tblr_used_column_types_str \c_tblr_primitive_column_types_str
\bool_new:N \g_tblr_column_spec_expand_stop_bool

\msg_new:nnn { tabularray } { used-column-type }
  { Column ~ type ~ name ~ #1 ~ has ~ been ~ used! }

\NewDocumentCommand \NewColumnType { m O{0} o m }
  {
    \str_if_in:NnTF \g_tblr_used_column_types_str { #1 }
      {
        \msg_warning:nnn { tabularray } { used-column-type } { #1 }
        \str_log:N \g_tblr_used_column_types_str
      }
      {
        \__tblr_make_xparse_arg_spec:nnN { #2 } { #3 } \l__tblr_a_tl
        \exp_args:NcV \NewDocumentCommand { tblr_column_type_ #1 } \l__tblr_a_tl
          {
            \bool_gset_false:N \g_tblr_column_spec_expand_stop_bool
            \tl_gput_right:Nf \g_tblr_expanded_colspec_tl { #4 }
            \__tblr_expand_column_spec_next:N
          }
        \str_gput_right:Nn \g_tblr_used_column_types_str { #1 }
      }
  }

\NewColumnType { l } { Q[l] }
\NewColumnType { c } { Q[c] }
\NewColumnType { r } { Q[r] }

\NewColumnType { t } [1] { Q[t,wd=#1] }
\NewColumnType { p } [1] { Q[p,wd=#1] }
\NewColumnType { m } [1] { Q[m,wd=#1] }
\NewColumnType { b } [1] { Q[b,wd=#1] }

\NewColumnType { X } [1][] { Q[co=1,#1] }

\NewColumnType { ! } [1] { |[tt={#1}] }
\NewColumnType { @ } [1] { <[0pt]{} |[tt={#1}] >[0pt]{} }
\NewColumnType { * } [2] { \prg_replicate:nn {#1} {#2} }

\cs_new_protected:Npn \__tblr_parse_column_spec:n #1
  {
    \tl_gset:Nn \g_tblr_expanded_colspec_tl { #1 }
    \__tblr_expand_column_spec:N \g_tblr_expanded_colspec_tl
    \__tblr_execute_column_spec:N \g_tblr_expanded_colspec_tl
  }

%% Expand defined column types

\cs_new_protected:Npn \__tblr_expand_column_spec:N #1
  {
    \bool_do_until:Nn \g_tblr_column_spec_expand_stop_bool
      {
        \tl_log:N #1
        \bool_gset_true:N \g_tblr_column_spec_expand_stop_bool
        \tl_set_eq:NN \l_tmpa_tl #1
        \tl_gclear:N #1
        \exp_last_unbraced:NV
          \__tblr_expand_column_spec_next:N \l_tmpa_tl \scan_stop:
      }
  }

\msg_new:nnn { tabularray } { unexpandable-column-type }
  { Unexpandable ~ command ~ #1 inside ~ column ~ type! }

\msg_new:nnn { tabularray } { unknown-column-type }
  { Unknown ~ column ~ type ~ #1! }

\cs_new_protected:Npn \__tblr_expand_column_spec_next:N #1
  {
    \token_if_eq_catcode:NNTF #1 \scan_stop:
      {
        \token_if_eq_meaning:NNF #1 \scan_stop:
          { \msg_error:nnn { tabularray } { unexpandable-column-type } { #1 } }
      }
      {
        \str_if_in:NnTF \g_tblr_used_column_types_str { #1 }
          { \cs:w tblr_column_type_  #1 \cs_end: }
          {
            \msg_error:nnn { tabularray } { unknown-column-type } { #1 }
            \str_log:N \g_tblr_used_column_types_str
          }
      }
  }

%% Execute primitive column types

\cs_new_protected:Npn \__tblr_execute_column_spec:N #1
  {
    \int_zero:N \colnum
    \exp_last_unbraced:NV \__tblr_execute_column_spec_next:N #1 \scan_stop:
  }

\cs_new_protected:Npn \__tblr_execute_column_spec_next:N #1
  {
    \token_if_eq_meaning:NNF #1 \scan_stop:
      { \cs:w tblr_primitive_column_type_  #1 \cs_end: }
  }

%% Calculate the width and height of every cell and border

\cs_new_protected:Npn \__tblr_calculate_cell_and_line_size:
  {
    \__tblr_calculate_cell_and_line_size_once:
    \__tblr_disable_table_commands:
    \__tblr_compute_extendable_column_width:
    \__tblr_compute_spanned_column_width:
  }

%% Calculate the width and height of every cell and border once
\cs_new_protected:Npn \__tblr_calculate_cell_and_line_size_once:
  {
    %% We need these two counters in executing table commands inside cells
    \int_zero:N \rownum
    \int_zero:N \colnum
    \int_step_inline:nn { \l_tblr_row_count_int }
      {
        \int_incr:N \rownum
        \int_zero:N \colnum
        \int_step_inline:nn { \l_tblr_col_count_int }
          {
            \int_incr:N \colnum
            \__tblr_measure_and_update_vline_size:nnN
              { \int_use:N \rownum } { \int_use:N \colnum } \l__tblr_w_dim
            \__tblr_measure_and_update_cell_size:nnNNN
              { \int_use:N \rownum }
              { \int_use:N \colnum }
              \l__tblr_w_dim
              \l__tblr_h_dim
              \l__tblr_d_dim
          }
        \__tblr_measure_and_update_vline_size:nnN
          { \int_use:N \rownum } { \int_eval:n {\colnum + 1} } \l__tblr_w_dim
      }
    \__tblr_prop_log:n {spec }
  }

%% Measure and update width of the vline
%% #1: row number, #2 column number, #3: width dimension
\cs_new_protected:Npn \__tblr_measure_and_update_vline_size:nnN #1 #2 #3
  {
    \hbox_set:Nn \l__tblr_b_box
      { \__tblr_get_vline_text:nn { #1 } { #2 } }
    \dim_set:Nn #3 { \box_wd:N \l__tblr_b_box }
    \tl_set:Nx \l__tblr_w_tl
      { \__tblr_prop_item:ne { spec } { vline[#2] / content-width } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l__tblr_w_tl }
      { \dim_compare_p:nNn { \dim_use:N #3 } > { \l__tblr_w_tl } }
      {
        \__tblr_prop_gput:nxx { spec }
          { vline[#2]/ content-width } { \dim_use:N #3 }
      }
  }

%% Get vline text, #1: row number, #2: column number
\cs_new_protected:Npn \__tblr_get_vline_text:nn #1 #2
  {
    \__tblr_prop_item:ne { spec } { vline[#1][#2] / text }
  }

%% Measure and update natural dimensions of the row/column/cell
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_measure_and_update_cell_size:nnNNN #1 #2 #3 #4 #5
  {
    \__tblr_measure_cell_size:nnNNN { #1 } { #2 } #3 #4 #5
    \__tblr_update_cell_size:nnNNN { #1 } { #2 } #3 #4 #5
    \__tblr_update_row_col_size:nnNNN { #1 } { #2 } #3 #4 #5
  }

%% Measure natural dimensions of the cell
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_measure_cell_size:nnNNN #1 #2 #3 #4 #5
  {
    \hbox_set:Nn \l__tblr_c_box
      { \__tblr_get_cell_text:nn { #1 } { #2 } }
    \dim_set:Nn #3 { \box_wd:N \l__tblr_c_box }
    \dim_set:Nn #4 { \box_ht:N \l__tblr_c_box }
    \dim_set:Nn #5 { \box_dp:N \l__tblr_c_box }
  }

%% Get cell text, #1: row number, #2: column number
%% If the width of the cell is set, build a vbox,
%% else if there is any \\ inside it, treat it as a subtable

\cs_new_eq:NN \__tlbr_vbox_top:n    \tex_vtop:D
\cs_new_eq:NN \__tlbr_vbox_middle:n \tex_vcenter:D
\cs_new_eq:NN \__tlbr_vbox_bottom:n \tex_vbox:D
\cs_new_eq:NN \__tlbr_halign_left:   \raggedright
\cs_new_eq:NN \__tlbr_halign_center: \center
\cs_new_eq:NN \__tlbr_halign_right:  \raggedleft

\cs_new_protected:Npn \__tblr_get_cell_text:nn #1 #2
  {
    \tl_set:Nx \l__tblr_c_tl { \__tblr_prop_item:ne { cell } { ( #1, #2 ) } }
    \tl_set:Nx \l__tblr_h_tl
      { \__tblr_prop_item:ne { spec } { col[#2] / halign } }
    \tl_set:Nx \l__tblr_v_tl
      { \__tblr_prop_item:ne { spec } { col[#2] / valign } }
    \tl_set:Nx \l__tblr_w_tl
      { \__tblr_prop_item:ne { spec } { cell[#1][#2] / span-width } }
    \tl_if_empty:NT \l__tblr_w_tl
      {
        \tl_set:Nx \l__tblr_w_tl
          { \__tblr_prop_item:ne { spec } { col[#2] / width } }
      }
    \tl_if_empty:NTF \l__tblr_w_tl
      {
        \tl_set_eq:NN \l_tmpa_tl \l__tblr_c_tl
        \__tblr_insert_braces:N \l_tmpa_tl
        \seq_set_split:NnV \l_tmpa_seq { \\ } \l_tmpa_tl
        \int_compare:nNnT { \seq_count:N \l_tmpa_seq } > { 1 }
          {
            \tl_put_left:Nn \l__tblr_c_tl { \begin{tblr}{ @{} Q @{} } }
            \tl_put_right:Nn \l__tblr_c_tl { \end{tblr} }
          }
        \l__tblr_c_tl
      }
      {
        $ \m@th \cs:w __tlbr_vbox_ \l__tblr_v_tl :n \cs_end: {
            \dim_set:Nn \tex_hsize:D { \l__tblr_w_tl }
            \cs:w __tlbr_halign_ \l__tblr_h_tl : \cs_end:
            \l__tblr_c_tl
        } $
      }
  }

%% Update natural dimensions of the cell
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_update_cell_size:nnNNN #1 #2 #3 #4 #5
  {
    \tl_set:Nx \l_tblr_a_tl
      { \__tblr_prop_item:ne { spec } { cell[#1][#2] / colspan } }
    \tl_set:Nx \l_tblr_b_tl
      { \__tblr_prop_item:ne { spec } { cell[#1][#2] / span-width } }
    \tl_if_empty:NTF \l_tblr_a_tl
      {
        \__tblr_prop_gput:nxx
          { spec } { cell[#1][#2] / content-width } { \dim_use:N #3 }
      }
      {
        \tl_if_empty:NTF \l_tblr_b_tl
          {
            \__tblr_prop_gput:nxx
              { spec } { cell[#1][#2] / natural-width } { \dim_use:N #3 }
          }
          {
            \__tblr_prop_gput:nxx
              { spec } { cell[#1][#2] / content-width } { \dim_use:N #3 }
          }
        \dim_zero:N #3 % don't affect column width
      }
    \__tblr_prop_gput:nxx
      { spec } { cell[#1][#2] / content-height } { \dim_use:N #4 }
    \__tblr_prop_gput:nxx
      { spec } { cell[#1][#2] / content-depth } { \dim_use:N #5 }
  }

%% Update natural dimensions of the row and the column
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_update_row_col_size:nnNNN #1 #2 #3 #4 #5
  {
    %% Update natural width for every column
    \tl_set:Nx \l_tmpb_tl
      { \__tblr_prop_item:ne { spec } { col[#2] / content-width } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      { \dim_compare_p:nNn { \dim_use:N #3 } > { \l_tmpb_tl } }
      {
        \__tblr_prop_gput:nxx { spec } { col[#2]/ content-width } { \dim_use:N #3 }
      }
    %% Update natural height for every row
    \tl_set:Nx \l_tmpb_tl
      { \__tblr_prop_item:ne { spec } { row[#1] / content-height } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      { \dim_compare_p:nNn { \dim_use:N #4 } > { \l_tmpb_tl } }
      {
        \__tblr_prop_gput:nxx { spec } { row[#1] / content-height } { \dim_use:N #4 }
      }
    %% Update natural depth for every row
    \tl_set:Nx \l_tmpb_tl
      { \__tblr_prop_item:ne { spec } { row[#1] / content-depth } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      { \dim_compare_p:nNn { \dim_use:N #5 } > { \l_tmpb_tl } }
      {
        \__tblr_prop_gput:nxx { spec } { row[#1] / content-depth } { \dim_use:N #5 }
      }
  }

%% Compute column widths when there are some extendable columns

\dim_new:N \l__column_target_dim
\prop_new:N \l__column_coefficient_prop
\prop_new:N \l__column_natural_width_prop
\prop_new:N \l__column_computed_width_prop

\msg_new:nnn { tabularray } { table-width-too-small }
  { Table ~ width ~ is ~ too ~ small, need ~ #1 ~ more! }

\cs_new_protected:Npn \__tblr_compute_extendable_column_width:
  {
    \__tblr_collect_extendable_column_width:
    \dim_compare:nNnTF { \l__column_target_dim } > { 0pt }
      {
        \prop_if_empty:NF \l__column_coefficient_prop
          { \__tblr_adjust_extendable_column_width: }
      }
      {
        \msg_warning:nnx { tabularray } { table-width-too-small }
          { \dim_abs:n { \l__column_target_dim } }
      }
  }

\cs_new_protected:Npn \__tblr_collect_extendable_column_width:
  {
    \tl_set:Nx \l_tmpa_tl { \__tblr_prop_item:nn { spec } { width } }
    \tl_if_empty:NTF \l_tmpa_tl
      { \dim_set_eq:NN \l__column_target_dim \linewidth }
      { \dim_set:Nn \l__column_target_dim { \l_tmpa_tl } }
    \prop_clear:N \l__column_coefficient_prop
    \prop_clear:N \l__column_natural_width_prop
    \prop_clear:N \l__column_computed_width_prop
    \int_step_variable:nNn { \l_tblr_col_count_int } \l__tblr_j_tl
      {
        \tl_set:Nx \l__tblr_a_tl
          { \__tblr_prop_item:ne { spec } { col[\l__tblr_j_tl] / width } }
        \tl_set:Nx \l__tblr_b_tl
          { \__tblr_prop_item:ne { spec } { col[\l__tblr_j_tl] / coefficient } }
        \tl_set:Nx \l__tblr_c_tl
          { \__tblr_prop_item:ne { spec } { col[\l__tblr_j_tl] / content-width } }
        \tl_if_empty:NTF \l__tblr_a_tl
          {
            \tl_if_empty:NTF \l__tblr_b_tl
              { \dim_sub:Nn \l__column_target_dim { \l__tblr_c_tl } }
              {
                \prop_put:Nxx \l__column_coefficient_prop
                  { \l__tblr_j_tl } { \l__tblr_b_tl }
                \prop_put:Nxn \l__column_computed_width_prop
                  { \l__tblr_j_tl } { 0pt }
                \dim_compare:nNnF { \l__tblr_b_tl pt } > { 0pt }
                  {
                    \prop_put:Nxx \l__column_natural_width_prop
                      { \l__tblr_j_tl } { \l__tblr_c_tl }
                  }
              }
          }
          { \dim_sub:Nn \l__column_target_dim { \l__tblr_a_tl } }
        \tl_set:Nx \l__tblr_a_tl
          { \__tblr_prop_item:ne { spec } { vline[\l__tblr_j_tl] / content-width } }
        \tl_set:Nx \l__tblr_b_tl
          { \__tblr_prop_item:ne { spec } { col[\l__tblr_j_tl] / colsep-left } }
        \tl_set:Nx \l__tblr_c_tl
          { \__tblr_prop_item:ne { spec } { col[\l__tblr_j_tl] / colsep-right } }
        \dim_set:Nn \l__column_target_dim
          { \l__column_target_dim - \l__tblr_a_tl - \l__tblr_b_tl - \l__tblr_c_tl }
      }
    \tl_set:Nx \l__tblr_a_tl
      { \__tblr_prop_item:ne { spec }
        { vline[\int_eval:n {\l_tblr_col_count_int + 1}] / content-width } }
    \tl_if_empty:NF \l__tblr_a_tl
      { \dim_sub:Nn \l__column_target_dim { \l__tblr_a_tl } }
    \dim_log:N \l__column_target_dim
    \prop_log:N \l__column_coefficient_prop
    \prop_log:N \l__column_natural_width_prop
  }

%% If all columns have negative coefficients and small natural widths,
%% \l__column_coefficient_prop will be empty after one or more rounds
\cs_new_protected:Npn \__tblr_adjust_extendable_column_width:
  {
    \bool_while_do:nn
      { \dim_compare_p:nNn { \l__column_target_dim } > { \hfuzz } }
      {
        \prop_if_empty:NTF \l__column_coefficient_prop
          { \__tblr_adjust_extendable_column_width_negative: }
          { \__tblr_adjust_extendable_column_width_once: }
      }
    \prop_map_inline:Nn \l__column_computed_width_prop
      {
        \__tblr_prop_gput:nnx { spec } { col[##1] / width } { ##2 }
        \__tblr_prop_gput:nnn { spec } { col[##1] / content-width } { 0pt }
      }
    \__tblr_calculate_cell_and_line_size_once:
  }

%% We use dimen register, since the coefficient may be a decimal number
\cs_new_protected:Npn \__tblr_adjust_extendable_column_width_once:
  {
    \dim_zero:N \l_tmpa_dim
    \prop_map_inline:Nn \l__column_coefficient_prop
      {
        \dim_add:Nn \l_tmpa_dim { \dim_abs:n { ##2 pt } }
      }
    \tl_set:Nx \l__tblr_w_tl
      { \dim_ratio:nn { \l__column_target_dim } { \l_tmpa_dim } }
    \dim_zero:N \l__column_target_dim
    \prop_map_inline:Nn \l__column_coefficient_prop
      {
        \tl_set:Nx \l__tblr_a_tl
          { \dim_eval:n { \dim_abs:n { ##2 pt } * \l__tblr_w_tl } }
        \dim_compare:nNnTF { ##2 pt } > { 0pt }
          {
            \__tblr_increase_prop_dimen_value:Nnn
              \l__column_computed_width_prop { ##1 } { \l__tblr_a_tl }
          }
          {
            \tl_set:Nx \l__tblr_b_tl
              { \prop_item:Nn \l__column_natural_width_prop { ##1 } }
            \tl_set:Nx \l__tblr_c_tl
              { \prop_item:Nn \l__column_computed_width_prop { ##1 } }
            \dim_compare:nNnTF { \l__tblr_a_tl + \l__tblr_c_tl } > { \l__tblr_b_tl }
              {
                \prop_put:Nnx \l__column_computed_width_prop
                  { ##1 } { \l__tblr_b_tl }
                \dim_add:Nn \l__column_target_dim
                  { \l__tblr_a_tl + \l__tblr_c_tl - \l__tblr_b_tl }
                \prop_remove:Nn \l__column_coefficient_prop { ##1 }
              }
              {
                \__tblr_increase_prop_dimen_value:Nnn
                  \l__column_computed_width_prop { ##1 } { \l__tblr_a_tl }
              }
          }
      }
    \dim_log:N \l__column_target_dim
    \prop_log:N \l__column_coefficient_prop
    \prop_log:N \l__column_computed_width_prop
  }

\cs_new_protected:Npn \__tblr_adjust_extendable_column_width_negative:
  {
    \dim_zero:N \l_tmpa_dim
    \prop_map_inline:Nn \l__column_natural_width_prop
      { \dim_add:Nn \l_tmpa_dim { ##2 } }
    \tl_set:Nx \l_tmpa_tl
      { \dim_ratio:nn { \l__column_target_dim } { \l_tmpa_dim } }
    \dim_zero:N \l__column_target_dim
    \prop_map_inline:Nn \l__column_natural_width_prop
      {
        \tl_set:Nx \l_tmpb_tl { \dim_eval:n { ##2 * \l_tmpa_tl } }
        \__tblr_increase_prop_dimen_value:Nnn
          \l__column_computed_width_prop { ##1 } { \l_tmpb_tl }
      }
    \dim_log:N \l__column_target_dim
    \prop_log:N \l__column_coefficient_prop
    \prop_log:N \l__column_computed_width_prop
  }

%% #1: the prop list, #2: the key, #3: the dimen to add
\cs_new_protected:Npn \__tblr_increase_prop_dimen_value:Nnn #1 #2 #3
  {
    \prop_put:Nnx #1 { #2 } { \dim_eval:n { \prop_item:Nn #1 { #2 } + #3 } }
  }

%% Legacy \multicolumn and \multirow commands
%% Both of them will call \MultiCell command in the end
%% We can not use \NewTableCommand since the gobble functions are different

\clist_gput_right:Nn \g__tblr_table_commands_clist { \multicolumn, \multirow }

\cs_new_protected:Npn \__tblr_table_command_multicolumn:w #1 #2 #3
  {
    \MultiCell[c=#1]{#2} #3
  }
\cs_new_protected:Npn \__tblr_table_command_multicolumn_gobble:w #1 #2 #3 { #3 }

\NewDocumentCommand \__tblr_table_command_multirow:w { O{m} m m +m }
  {
    \MultiCell[r=#2]{#1,#3} #4
  }
\NewDocumentCommand \__tblr_table_command_multirow_gobble:w { O{m} m m +m } { #4 }

%% \MultiSell and \SetCell commands are for multirow and/or multicolumn cells.
%% \MultiSell will compute column widths from spancell widths,
%% while \SetCell will compute spancell widths from column widths.

\NewTableCommand \MultiCell [2] []
  {
    \__tblr_set_cell_span:
    \bool_gset_false:N \g__tblr_span_widths_from_column_widths_bool
    \keys_set:nn { tblr-cell } { #1 }
  }

\NewTableCommand \SetCell [2] []
  {
    \__tblr_set_cell_span:
    \bool_gset_true:N \g__tblr_span_widths_from_column_widths_bool
    \keys_set:nn { tblr-cell } { #1 }
  }

\keys_define:nn { tblr-cell }
  {
    c .code:n = \__tblr_set_cell_colspan:n { #1 },
    r .code:n = \__tblr_set_cell_rowspan:n { #1 },
  }

\cs_new_protected:Npn \__tblr_set_cell_span:
  {
    \__tblr_prop_gput:nnn { spec } { cellspan } { true }
  }

\cs_new_protected:Npn \__tblr_set_cell_colspan:n #1
  {
    \int_compare:nNnT { #1 } > { 1 }
      {
        \__tblr_prop_gput:nxn { spec }
          { cell[\int_use:N \rownum][\int_use:N \colnum] / colspan } { #1 }
        \int_step_inline:nn { #1 - 1 }
          {
            \__tblr_prop_gput:nxx { cell }
              { (\int_use:N \rownum, \int_eval:n {\colnum + ##1}) } { }
            \__tblr_prop_gput:nxx { spec }
              { vline[\int_use:N \rownum][\int_eval:n {\colnum + ##1}] / text } { }
          }
      }
  }

\cs_new_protected:Npn \__tblr_set_cell_rowspan:n #1
  {
    \int_compare:nNnT { #1 } > { 1 }
      {
        \__tblr_prop_gput:nxn { spec }
          { cell[\int_use:N \rownum][\int_use:N \colnum] / rowspan } { #1 }
      }
  }

%% Compute and adjust widths when there are some spancells

\bool_new:N \g__tblr_span_widths_from_column_widths_bool
\prop_new:N \l__tblr_col_width_skip_prop

\cs_new_protected:Npn \__tblr_compute_spanned_column_width:
  {
    \__tblr_prop_if_in:nnT { spec } { cellspan }
      {
        \__tblr_collect_column_width_skip:
        \bool_if:NTF \g__tblr_span_widths_from_column_widths_bool
          { \__tblr_set_span_widths_from_column_widths: }
          { \__tblr_set_column_widths_from_span_widths: }
        \__tblr_prop_log:n { spec }
        \__tblr_calculate_cell_and_line_size_once:
      }
  }

\cs_new_protected:Npn \__tblr_collect_column_width_skip:
  {
    \prop_clear:N \l__tblr_col_width_skip_prop
    \int_step_variable:nNn { \l_tblr_col_count_int } \l__tblr_j_tl
      {
        \int_compare:nNnTF { \l__tblr_j_tl } > { 1 }
          {
            \prop_put:Nxx \l__tblr_col_width_skip_prop { skip[\l__tblr_j_tl] }
              {
                \dim_eval:n
                  {
                    \__tblr_prop_item:ne { spec }
                      { col[\l__tblr_j_tl] / colsep-left }
                    +
                    \__tblr_prop_item:ne { spec }
                      { vline[\l__tblr_j_tl] / content-width }
                    +
                    \__tblr_prop_item:ne { spec }
                      { col[\l__tblr_j_tl] / colsep-right }
                  }
              }
          }
          {
            \prop_put:Nxn \l__tblr_col_width_skip_prop { skip[\l__tblr_j_tl] }
              { 0pt }
          }
        \prop_put:Nxx \l__tblr_col_width_skip_prop { col[\l__tblr_j_tl] }
          { \__tblr_prop_item:ne { spec } { col[\l__tblr_j_tl] / content-width } }
      }
    \prop_log:N \l__tblr_col_width_skip_prop
  }

\cs_new_protected:Npn \__tblr_set_span_widths_from_column_widths:
  {
    \int_step_variable:nNn { \l_tblr_col_count_int } \l__tblr_j_tl
      {
        \int_step_variable:nNn { \l_tblr_row_count_int } \l__tblr_i_tl
          {
            \tl_set:Nx \l__tblr_a_tl
              {
                \__tblr_prop_item:ne { spec }
                  { cell[\l__tblr_i_tl][\l__tblr_j_tl] / colspan }
              }
            \tl_if_empty:NF \l__tblr_a_tl
              {
                \__tblr_get_spanned_column_width:xxN
                  { \l__tblr_j_tl }
                  { \int_eval:n { \l__tblr_j_tl + \l__tblr_a_tl - 1 } }
                  \l__tblr_w_dim
                \__tblr_prop_gput:nxx { spec }
                  { cell[\l__tblr_i_tl][\l__tblr_j_tl] / span-width }
                  { \dim_use:N \l__tblr_w_dim }
              }
          }
      }
  }

%% Cell is spanned from col #1 to col #2, #3 is the return dim
\cs_new_protected:Npn \__tblr_get_spanned_column_width:nnN #1 #2 #3
  {
    \dim_zero:N #3
    \int_step_inline:nnn { #1 } { #2 }
      {
        \tl_set:Nx \l_tmpa_tl
          { \prop_item:Ne \l__tblr_col_width_skip_prop { skip[##1] } }
        \tl_set:Nx \l_tmpb_tl
          { \prop_item:Ne \l__tblr_col_width_skip_prop { col[##1] } }
        \dim_add:Nn #3 { \dim_eval:n { \l_tmpa_tl + \l_tmpb_tl } }
      }
  }
\cs_generate_variant:Nn \dim_add:Nn {Nx}
\cs_generate_variant:Nn \__tblr_get_spanned_column_width:nnN { xxN }

%% Compute and set column widths from span widths

\prop_new:N \l__tblr_span_width_prop

\cs_new_protected:Npn \__tblr_set_column_widths_from_span_widths:
  {
    \int_step_variable:nNn { \l_tblr_col_count_int } \l__tblr_j_tl
      {
        \int_step_variable:nNn { \l_tblr_row_count_int } \l__tblr_i_tl
          {
            \tl_set:Nx \l__tblr_a_tl
              {
                \__tblr_prop_item:ne { spec }
                  { cell[\l__tblr_i_tl][\l__tblr_j_tl] / colspan }
              }
            \tl_if_empty:NF \l__tblr_a_tl
              {
                \prop_put:Nxx \l__tblr_span_width_prop
                  {
                    ( \l__tblr_j_tl -
                      \int_eval:n {\l__tblr_j_tl + \l__tblr_a_tl - 1} )
                  }
                  {
                    \__tblr_prop_item:ne { spec }
                      { cell[\l__tblr_i_tl][\l__tblr_j_tl] / natural-width }
                  }
              }
          }
        \__tblr_set_column_width_from_span_width_once:
      }
    \prop_log:N \l__tblr_span_width_prop
    \prop_log:N \l__tblr_col_width_skip_prop
  }

%% See TeXbook chapter 22, Page 245
\cs_new_protected:Npn \__tblr_set_column_width_from_span_width_once:
  {
    \dim_set:Nn \l__tblr_w_dim
      {
        \prop_item:Ne \l__tblr_col_width_skip_prop { col[\l__tblr_j_tl] }
      }
    \int_step_inline:nn { \l__tblr_j_tl - 1 }
      {
        \tl_set:Nx \l__tblr_a_tl
          { \prop_item:Ne \l__tblr_span_width_prop { (##1-\l__tblr_j_tl) } }
        \tl_if_empty:NF \l__tblr_a_tl
          {
            \int_step_inline:nnn { ##1 } { \l__tblr_j_tl - 1 }
              {
                \tl_log:x { \l__tblr_j_tl : ##1 -> ####1 }
                \tl_set:Nx \l_tmpa_tl
                  {
                    \prop_item:Nn \l__tblr_col_width_skip_prop { colskip[####1] }
                  }
                \tl_set:Nx \l__tblr_a_tl
                  { \dim_eval:n { \l__tblr_a_tl - \l_tmpa_tl } }
              }
            \dim_compare:nNnT { \l__tblr_a_tl } > { \dim_use:N \l__tblr_w_dim }
              {
                \dim_set:Nn \l__tblr_w_dim { \l__tblr_a_tl }
              }
          }
      }
    \prop_put:Nxx \l__tblr_col_width_skip_prop
      { col[\l__tblr_j_tl] } { \dim_use:N \l__tblr_w_dim }
    \__tblr_prop_gput:nxx { spec }
      { col[\l__tblr_j_tl] / content-width } { \dim_use:N \l__tblr_w_dim }
    \int_compare:nNnT { \l__tblr_j_tl } < { \l_tblr_col_count_int }
      {
        \tl_set:Nx \l_tmpb_tl
          {
            \prop_item:Ne \l__tblr_col_width_skip_prop
              { skip[\int_eval:n { \l__tblr_j_tl + 1} ] }
          }
        \dim_add:Nn \l__tblr_w_dim { \l_tmpb_tl }
        \prop_put:Nxx \l__tblr_col_width_skip_prop
          { colskip[\l__tblr_j_tl] } { \dim_use:N \l__tblr_w_dim }
      }
  }

%% Build the whole table
\cs_new_eq:NN \__tlbr_vbox_t:n \tex_vtop:D
\cs_new_eq:NN \__tlbr_vbox_c:n \tex_vcenter:D
\cs_new_eq:NN \__tlbr_vbox_b:n \tex_vbox:D
\cs_new_protected:Npn \__tblr_build_whole:n #1
  {
    \tex_hbox:D
      { $ \m@th \cs:w __tlbr_vbox_ #1 :n \cs_end:
          {
            \int_step_variable:nNn { \l_tblr_row_count_int } \l__tblr_i_tl
              {
                \__tblr_prop_if_in:nxTF { spec } { hline[\l__tblr_i_tl] / style }
                  { \hrule }
                  { \hrule height ~ 0pt } % remove lineskip between two rows
                \tex_hbox:D
                  {
                    \__tblr_build_row:N \l__tblr_i_tl
                  }
              }
            \__tblr_prop_if_in:nxT { spec }
              { hline[\int_eval:n {\l_tblr_row_count_int + 1}] / style }
              { \hrule }
          } $
      }
  }

%% Build current row, #1: row number
\cs_new_protected:Npn \__tblr_build_row:N #1
  {
    \__tblr_get_row_inner_height_depth:VNN #1 \l__tblr_h_dim \l__tblr_d_dim
    \vrule width ~ 0pt ~ height ~ \l__tblr_h_dim ~ depth ~ \l__tblr_d_dim
    \int_step_variable:nNn { \l_tblr_col_count_int } \l__tblr_j_tl
      {
        \__tblr_build_vline:nn { #1 } { \l__tblr_j_tl }
        \__tblr_build_cell:NN #1 \l__tblr_j_tl
      }
    \__tblr_build_vline:nn { #1 } { \int_eval:n {\l_tblr_col_count_int + 1} }
  }

\cs_new_protected:Npn \__tblr_build_vline:nn #1 #2
  {
    \tl_set:Nx \l__tblr_w_tl
      { \__tblr_prop_item:ne { spec } { vline[#2] / content-width } }
    \hbox_set_to_wd:Nnn \l__tblr_c_box { \l__tblr_w_tl }
      { \__tblr_get_vline_text:nn { #1 } { #2 } }
    \box_set_ht:Nn \l__tblr_c_box { \dim_use:N \l__tblr_h_dim }
    \box_set_dp:Nn \l__tblr_c_box { \dim_use:N \l__tblr_d_dim }
    \box_use:N \l__tblr_c_box
  }

\cs_new_protected:Npn \__tblr_build_cell:NN #1 #2
  {
    \tl_set:Nx \l__tblr_w_tl
      { \__tblr_prop_item:ne { spec } { col[#2] / content-width } }
    \tl_set:Nx \l__tblr_a_tl
      { \__tblr_prop_item:ne { spec } { col[#2] / halign } }
    \skip_horizontal:n
      { \__tblr_prop_item:ne { spec } { col[#2] / colsep-left } }
    \hbox_set_to_wd:Nnn \l__tblr_c_box { \l__tblr_w_tl }
      {
        \tl_if_eq:NnF \l__tblr_a_tl { left } { \hfil }
        \__tblr_get_cell_text:nn { #1 } { #2 }
        \tl_if_eq:NnT \l__tblr_a_tl { center } { \hfil }
      }
    \box_set_ht:Nn \l__tblr_c_box
      { \__tblr_prop_item:ne { spec } { row[#1] / content-height } }
    \box_set_dp:Nn \l__tblr_c_box
      { \__tblr_prop_item:ne { spec } { row[#1] / content-depth } }
    \box_use:N \l__tblr_c_box
    \skip_horizontal:n
      { \__tblr_prop_item:ne { spec } { col[#2] / colsep-right } }
  }

%% Read from table specifications and calculate inner height of row
%% inner height = rowsep above  + natural height
%% inner depth  = natural depth + rowsep below
%% #1: the row number, #2: inner height, #3: inner depth
\cs_new_protected:Npn \__tblr_get_row_inner_height_depth:nNN #1 #2 #3
  {
    \tl_set:Nx \l_tblr_a
      { \__tblr_prop_item:ne { spec } { row[#1] / rowsep-above } }
    \tl_set:Nx \l_tblr_h
      { \__tblr_prop_item:ne { spec } { row[#1] / content-height } }
    \tl_set:Nx \l_tblr_d
      { \__tblr_prop_item:ne { spec } { row[#1] / content-depth } }
    \tl_set:Nx \l_tblr_b
      { \__tblr_prop_item:ne { spec } { row[#1] / rowsep-below } }
    \dim_set:Nn #2 { \l_tblr_a + \l_tblr_h}
    \dim_set:Nn #3 { \l_tblr_d + \l_tblr_b }
  }
\cs_generate_variant:Nn \__tblr_get_row_inner_height_depth:nNN { V }

\ExplSyntaxOff

