%%% % -*- coding: utf-8 -*-
%%% ----------------------------------------------------------------------------
%%% Tabularray: Typeset tabulars and arrays with LaTeX3
%%% Author    : Jianrui Lyu <tolvjr@163.com>
%%% Repository: https://github.com/lvjr/tabularray
%%% License   : The LaTeX Project Public License 1.3
%%% ----------------------------------------------------------------------------

\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\ProvidesExplPackage{tabularray}{2021-03-15}{2021A}
  {Typeset tabulars and arrays with LaTeX3}

%\RequirePackage{xparse}

\ExplSyntaxOn

\NewDocumentEnvironment { tblr } { O{c} m +b }
  { \buildtblr { #1 } { #2 } { #3 } } { }

\cs_generate_variant:Nn \prop_item:Nn { Ne }
\cs_generate_variant:Nn \regex_replace_all:NnN { NVN }
\cs_generate_variant:Nn \seq_map_indexed_inline:Nn { cn }
\cs_generate_variant:Nn \tl_gput_right:Nn { Ne }
\cs_generate_variant:Nn \tl_if_blank:nTF { xTF }
\prg_generate_conditional_variant:Nnn \prop_if_in:Nn { c } { T }

\tl_new:N  \l_tblr_a_tl
\tl_new:N  \l_tblr_b_tl
\tl_new:N  \l_tblr_d_tl
\tl_new:N  \l_tblr_h_tl
\tl_new:N  \l_tblr_i_tl  % for row index
\tl_new:N  \l_tblr_j_tl  % for column index
\tl_new:N  \l_tblr_w_tl
\int_new:N \l_tblr_c_int % for column number
\int_new:N \l_tblr_r_int % for row number
\dim_new:N \l_tblr_d_dim % for depth
\dim_new:N \l_tblr_h_dim % for height
\dim_new:N \l_tblr_w_dim % for width
\box_new:N \l_tblr_c_box % for cell box

\int_new:N \g_tblr_level_int % store table nesting level
\prop_new:c { g_tblr_cell_1_prop } % store table cell text of level 1
\prop_new:c { g_tblr_spec_1_prop } % store table specification of level 1

\cs_new_protected:Npn \tblr_prop_gput:nnn #1 #2 #3
  {
    \prop_gput:cnn
      { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 } { #3 }
  }
\cs_generate_variant:Nn \tblr_prop_gput:nnn { nnV, nxn, nxx, nxV }

\cs_new:Npn \tblr_prop_item:nn #1 #2
  {
    \prop_item:cn { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 }
  }
\cs_generate_variant:Nn \tblr_prop_item:nn { ne }

\cs_new_protected:Npn \tblr_prop_if_in:nnT #1
  { \prop_if_in:cnT { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } }
\cs_new_protected:Npn \tblr_prop_if_in:nnTF #1
  { \prop_if_in:cnTF { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } }
\prg_generate_conditional_variant:Nnn \tblr_prop_if_in:nn { nx } { T, TF }

\cs_new_protected:Npn \tblr_prop_log:n #1
  {
    \prop_log:c { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop }
  }

%% Read, split and build the table

\cs_new_protected:Npn \buildtblr #1 #2 #3
  {
    \int_gincr:N \g_tblr_level_int
    \prop_gclear_new:c { g_tblr_cell_ \int_use:N \g_tblr_level_int _prop }
    \prop_gclear_new:c { g_tblr_spec_ \int_use:N \g_tblr_level_int _prop }
    \__tblr_split_table:n { #3 }
    \tblr_initial_table
    \tblr_parse_column_spec:n { #2 }
    \tblr_calculate_cell_size
    \tblr_build_whole:n { #1 }
    \int_gdecr:N \g_tblr_level_int
  }

%% Insert and remove braces for nesting environments inside cells
%% These make line split and cell split workable
%% We need to replace N times for N level nestings
\regex_const:Nn \c_tblr_insert_braces_regex
  {
    \c{begin} \cB\{ (\c[^BE].*) \cE\} (.*?) \c{end} \cB\{ (\c[^BE].*) \cE\}
  }
\tl_const:Nn \c_tblr_insert_braces_tl
  {
    \c{begin} \cB\{ \cB\{ \1 \cE\} \2 \c{end} \cE\} \cB\{ \3 \cE\}
  }
\regex_const:Nn \c_tblr_remove_braces_regex
  {
    \c{begin} \cB\{ \cB\{ (.*?) \c{end} \cE\}
  }
\tl_const:Nn \c_tblr_remove_braces_tl
  {
    \c{begin} \cB\{ \1 \c{end}
  }
\cs_new_protected:Npn \tblr_insert_braces:N #1
  {
    \regex_replace_all:NVN \c_tblr_insert_braces_regex \c_tblr_insert_braces_tl #1
    \regex_replace_all:NVN \c_tblr_insert_braces_regex \c_tblr_insert_braces_tl #1
  }
\cs_new_protected:Npn \tblr_remove_braces:N #1
  {
    \regex_replace_all:NVN \c_tblr_remove_braces_regex \c_tblr_remove_braces_tl #1
    \regex_replace_all:NVN \c_tblr_remove_braces_regex \c_tblr_remove_braces_tl #1
  }

%% Split table content to cells and store them
%% #1: table content

\seq_new:N \l_tblr_lines_seq
\int_new:N \l_tblr_row_count_int
\int_new:N \l_tblr_col_count_int

\cs_new_protected:Npn \__tblr_split_table:n #1
  {
    \int_zero:N \l_tblr_row_count_int
    \int_zero:N \l_tblr_col_count_int
    \__tblr_split_table_to_lines:nN { #1 } \l_tblr_lines_seq
    \__tblr_split_lines_to_cells:N \l_tblr_lines_seq
  }

%% Split table content to a sequence of lines
%% #1: table content, #2: resulting sequence of lines
\cs_new_protected:Npn \__tblr_split_table_to_lines:nN #1 #2
  {
    \tl_set:Nn \l_tmpa_tl { #1 }
    \tblr_insert_braces:N \l_tmpa_tl
    \seq_set_split:NnV \l_tmpa_seq { \\ } \l_tmpa_tl
    \seq_clear:N #2
    \seq_map_inline:Nn \l_tmpa_seq
      {
        \bool_lazy_or:nnTF
          { \tl_if_head_eq_meaning_p:nN { ##1 } * }
          { \tl_if_head_eq_meaning_p:nN { ##1 } [ }
          { \seq_put_right:Nn #2 { \tblr_newline_skip ##1 } }
          { \seq_put_right:Nn #2 { ##1 } }
      }
    \int_set:Nn \l_tblr_row_count_int { \seq_count:N #2 }
  }

%% Split table lines to cells and store them
%% #1: sequence of lines
\cs_new_protected:Npn \__tblr_split_lines_to_cells:N #1
  {
    \seq_map_indexed_function:NN #1 \tblr_split_one_line:nn
    \tblr_prop_log:n { cell }
  }

%% Split one line into cells and store them
%% #1: row number, #2 the line text
\cs_new_protected:Npn \tblr_split_one_line:nn #1 #2
  {
    \seq_set_split:Nnn \l_tmpa_seq { & } { #2 }
    \int_zero:N \l_tblr_c_int
    \seq_map_indexed_inline:Nn \l_tmpa_seq
      {
        \tl_set:Nn \l_tmpa_tl { ##2 }
        \tblr_remove_braces:N \l_tmpa_tl
        \tblr_prop_gput:nnV { cell } { ( #1, ##1 ) } \l_tmpa_tl
        \int_incr:N \l_tblr_c_int
      }
    \int_compare:nT { \l_tblr_c_int > \l_tblr_col_count_int }
      {
        \int_set_eq:NN \l_tblr_col_count_int \l_tblr_c_int
      }
  }

\cs_new_protected:Npn \tblr_initial_table
  {
    \tblr_initial_table_spec
    \tblr_initial_table_command
  }

\int_new:N \rownum
\int_new:N \colnum

\prop_const_from_keyval:Nn \c_tblr_default_keyval_row_prop
  {
    rowsep-above   = 0.2em,
    rowsep-below   = 0.2em,
    valign         = top,
    natural-height = 0pt,
    natural-depth  = 0pt,
  }

\prop_const_from_keyval:Nn \c_tblr_default_keyval_col_prop
  {
    colsep-left    = 0.6em,
    colsep-right   = 0.6em,
    halign         = left,
    natural-width  = 0pt,
  }

\prop_const_from_keyval:Nn \c_tblr_default_keyval_cell_prop
  {
    natural-width  = 0pt,
    natural-height = 0pt,
    natural-depth  = 0pt,
  }

\cs_new_protected:Npn \tblr_initial_table_spec
  {
    \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
      {
        \prop_map_inline:Nn \c_tblr_default_keyval_row_prop
          {
            \tblr_prop_gput:nxn { spec } { row[\l_tblr_i_tl] / ##1 } { ##2 }
          }
        \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
          {
            \prop_map_inline:Nn \c_tblr_default_keyval_cell_prop
              {
                \tblr_prop_gput:nxn { spec }
                  { cell[\l_tblr_i_tl][\l_tblr_j_tl] / ##1 } { ##2 }
              }
          }
      }
    \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
      {
        \prop_map_inline:Nn \c_tblr_default_keyval_col_prop
          {
            \tblr_prop_gput:nxn { spec } { col[\l_tblr_j_tl] / ##1 } { ##2 }
          }
      }
  }

\NewDocumentCommand { \settblr } { m }
  { \tblr_setup:n { #1 } }

%% Setup the table
\cs_new_protected:Npn \tblr_setup:n #1
  {
    \keys_set:nn { tblr } { #1 }
  }
\cs_generate_variant:Nn \tblr_setup:n { x }

%% If the key doesn't exist, create it ahead
\cs_new_protected:Npn \tblr_keys_define_set:nn #1 #2
  {
    \keys_if_exist:nnF { tblr } { #1 }
      {
        \keys_define:nn { tblr }
          { #1 .code:n = \tblr_keys_gput:nn { #1 } { ##1 } }
      }
    \keys_set:nn { tblr } { #1 = #2 }
  }
\cs_generate_variant:Nn \tblr_keys_define_set:nn { x }

\cs_new_protected:Npn  \tblr_keys_gput:nn #1 #2
  { \tblr_prop_gput:nnn { spec } { #1 } { #2 } }

\keys_define:nn { tblr }
  {
    hline .code:n = \tblr_spec_hline:n{ #1 },
  }

%% Treat \\*[dimen] command
\NewDocumentCommand \tblr_newline_skip { s o }
  {
    \IfBooleanT { #1 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / pagebreak }
          { none }
      }
    \IfValueT { #2 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / extra-rowsep-below }
          { #2 }
      }
  }

\cs_new_protected:Npn \tblr_spec_hline:n #1
  {
    \tblr_prop_gput:nxx
      { spec }
      { hline[\int_use:N \rownum] / style }
      { solid }
  }

\cs_new_protected:Npn \tblr_initial_table_command
  {
    \cs_set_protected:Npn \hline
      { \tblr_setup:n { hline } }
  }

%% Some primitive column types

\clist_const:Nn \c_tblr_primitive_column_types_clist { Q, |, <, > }
\tl_new:N \g_tblr_expanded_colspec_tl

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ Q } { O{} }
  {
    \int_incr:N \colnum
    \keys_set:nn { tblr-column-type-Q } { #1 }
    \tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ Q } { O{} }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { Q[#1] }
    \tblr_expand_column_spec_next:N
  }

\keys_define:nn { tblr-column-type-Q }
  {
    l .code:n = \tblr_keys_define_set:xn
                  { col[\int_use:N \colnum] / halign } { left },
    c .code:n = \tblr_keys_define_set:xn
                  { col[\int_use:N \colnum] / halign } { center },
    r .code:n = \tblr_keys_define_set:xn
                  { col[\int_use:N \colnum] / halign } {right },
  }

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ | } { O{} }
  {
    \tblr_prop_gput:nxx
      { spec }
      { vline[\int_eval:n {\colnum + 1}] / style }
      { solid }
    \tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ | } { O{} }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { | }
    \tblr_expand_column_spec_next:N
  }

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ > } { O{} m }
  {
    \tl_if_blank:nF { #1 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { col[\int_eval:n {\colnum + 1}] / colsep-left }
          { \dim_eval:n { #1 } }
      }
    \tl_if_blank:nF { #2 }
      {
        \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
          {
            \tl_set:Nx \l_tmpa_tl
            {
              \tblr_prop_item:ne { cell }
                { (\l_tblr_i_tl,\int_eval:n {\colnum + 1}) }
            }
            \tl_put_left:Nn \l_tmpa_tl { #2 }
            \tblr_prop_gput:nxV
              { cell }
              { (\l_tblr_i_tl,\int_eval:n {\colnum + 1}) }
              \l_tmpa_tl
          }
      }
    \tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ > } { O{} m }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { >[#1]{#2} }
    \tblr_expand_column_spec_next:N
  }

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ < } { O{} m }
  {
    \tl_if_blank:nF { #1 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { col[\int_use:N \colnum] / colsep-right }
          { \dim_eval:n { #1 } }
      }
    \tl_if_blank:nF { #2 }
      {
        \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
          {
            \tl_set:Nx \l_tmpa_tl
            {
              \tblr_prop_item:ne { cell } { (\l_tblr_i_tl,\int_use:N \colnum) }
            }
            \tl_put_right:Nn \l_tmpa_tl { #2 }
            \tblr_prop_gput:nxV
              { cell }
              { (\l_tblr_i_tl,\int_use:N \colnum) }
              \l_tmpa_tl
          }
      }
    \tblr_execute_column_spec_next:N
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ < } { O{} m }
  {
    \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { <[#1]{#2} }
    \tblr_expand_column_spec_next:N
  }

%% \NewColumnType command and predefined column types

\clist_new:N \g_tblr_used_column_types_clist
\clist_gset_eq:NN
  \g_tblr_used_column_types_clist \c_tblr_primitive_column_types_clist
\bool_new:N \g_tblr_column_spec_expand_stop_bool

\msg_new:nnn { tblr } { used-column-type }
  { Column ~ type ~ name ~ #1 ~ has ~ been ~ used! }

\NewDocumentCommand \NewColumnType { m O{0} o m }
  {
    \clist_if_in:NnTF \g_tblr_used_column_types_clist { #1 }
      {
        \msg_warning:nnn { tblr } { used-column-type } { #1 }
        \clist_log:N \g_tblr_used_column_types_clist
      }
      {
        \tl_clear:N \l_tmpa_tl
        \int_compare:nNnT { #2 } > { 0 }
          {
            \IfValueTF { #3 }
              { \tl_set:Nn \l_tmpa_tl { O{#3} } }
              { \tl_set:Nn \l_tmpa_tl { m } }
            \tl_put_right:Nx \l_tmpa_tl { \prg_replicate:nn { #2 - 1 } { m } }
          }
        \exp_args:NcV \NewDocumentCommand { tblr_column_type_ #1 } \l_tmpa_tl
          {
            \bool_gset_false:N \g_tblr_column_spec_expand_stop_bool
            \tl_gput_right:Ne \g_tblr_expanded_colspec_tl { #4 }
            \tblr_expand_column_spec_next:N
          }
        \clist_gput_right:Nn \g_tblr_used_column_types_clist { #1 }
      }
  }

\NewColumnType { l } { Q[l] }
\NewColumnType { c } { Q[c] }
\NewColumnType { r } { Q[r] }

\cs_new_protected:Npn \tblr_parse_column_spec:n #1
  {
    \tl_gset:Nn \g_tblr_expanded_colspec_tl { #1 }
    \tblr_expand_column_spec:N \g_tblr_expanded_colspec_tl
    \tblr_execute_column_spec:N \g_tblr_expanded_colspec_tl
  }

%% Expand defined column types

\cs_new_protected:Npn \tblr_expand_column_spec:N #1
  {
    \bool_do_until:Nn \g_tblr_column_spec_expand_stop_bool
      {
        \tl_log:N #1
        \bool_gset_true:N \g_tblr_column_spec_expand_stop_bool
        \tl_set_eq:NN \l_tmpa_tl #1
        \tl_gclear:N #1
        \exp_last_unbraced:NV
          \tblr_expand_column_spec_next:N \l_tmpa_tl \scan_stop:
      }
  }

\msg_new:nnn { tblr } { unknown-column-type }
  { Unknown ~ column ~ type ~ #1! }

\cs_new_protected:Npn \tblr_expand_column_spec_next:N #1
  {
    \token_if_eq_meaning:NNF #1 \scan_stop:
      {
        \clist_if_in:NnTF \g_tblr_used_column_types_clist { #1 }
          {
            \cs:w tblr_column_type_  #1 \cs_end:
          }
          {
            \msg_warning:nnn { tblr } { unknown-column-type } { #1 }
            \clist_log:N \l_tmpa_clist
          }
      }
  }

%% Execute primitive column types

\cs_new_protected:Npn \tblr_execute_column_spec:N #1
  {
    \exp_last_unbraced:NV \tblr_execute_column_spec_next:N #1 \scan_stop:
  }

\cs_new_protected:Npn \tblr_execute_column_spec_next:N #1
  {
    \token_if_eq_meaning:NNF #1 \scan_stop:
      { \cs:w tblr_primitive_column_type_  #1 \cs_end: }
  }

%% Calculate the width and height of every cell
\cs_new_protected:Npn \tblr_calculate_cell_size
  {
    %% We need these two counters in executing table commands inside cells
    \int_zero:N \rownum
    \int_zero:N \colnum
    \int_step_inline:nn { \l_tblr_row_count_int }
      {
        \int_incr:N \rownum
        \int_zero:N \colnum
        \int_step_inline:nn { \l_tblr_col_count_int }
          {
            \int_incr:N \colnum
            \__tblr_measure_and_update_size:nnNNN
              { \int_use:N \rownum }
              { \int_use:N \colnum }
              \l_tblr_w_dim
              \l_tblr_h_dim
              \l_tblr_d_dim
          }
      }
    %% remove the last row when it has only \hline
    \tl_set:Nx \l_tblr_h_tl
      {
        \tblr_prop_item:ne { spec } { row[\l_tblr_row_count_int] / natural-height }
      }
    \tl_set:Nx \l_tblr_d_tl
      {
        \tblr_prop_item:ne { spec } { row[\l_tblr_row_count_int] / natural-depth }
      }
    \bool_lazy_and:nnT
      { \dim_compare_p:nNn { \l_tmpb_tl } = { 0pt } }
      { \dim_compare_p:nNn { \l_tmpb_tl } = { 0pt } }
      { \int_decr:N \l_tblr_row_count_int }
    \tblr_prop_log:n {spec }
  }

%% Measure and update natural dimensions of the row/column/cell
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_measure_and_update_size:nnNNN #1 #2 #3 #4 #5
  {
    \__tblr_measure_cell_size:nnNNN { #1 } { #2 } #3 #4 #5
    \__tblr_update_cell_size:nnNNN { #1 } { #2 } #3 #4 #5
    \__tblr_update_row_col_size:nnNNN { #1 } { #2 } #3 #4 #5
  }

%% Measure natural dimensions of the cell
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_measure_cell_size:nnNNN #1 #2 #3 #4 #5
  {
    \hbox_set:Nn \l_tblr_c_box
      {
        \tblr_prop_item:ne { cell } { ( #1, #2 ) }
      }
    \dim_set:Nn #3 { \box_wd:N \l_tblr_c_box }
    \dim_set:Nn #4 { \box_ht:N \l_tblr_c_box }
    \dim_set:Nn #5 { \box_dp:N \l_tblr_c_box }
  }

%% Update natural dimensions of the cell
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_update_cell_size:nnNNN #1 #2 #3 #4 #5
  {
    \tblr_prop_gput:nxx
      { spec } { cell[#1][#2] / natural-width } { \dim_use:N #3 }
    \tblr_prop_gput:nxx
      { spec } { cell[#1][#2] / natural-height } { \dim_use:N #4 }
    \tblr_prop_gput:nxx
      { spec } { cell[#1][#2] / natural-depth } { \dim_use:N #5 }
  }

%% Update natural dimensions of the row and the column
%% #1: row number, #2 column number
%% #3: width dimension, #4: height dimension, $5 depth dimension
\cs_new_protected:Npn \__tblr_update_row_col_size:nnNNN #1 #2 #3 #4 #5
  {
    %% Update natural width for every column
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { col[#2] / natural-width } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      { \dim_compare_p:nNn { \dim_use:N #3 } > { \l_tmpb_tl } }
      {
        \tblr_prop_gput:nxx { spec } { col[#2]/ natural-width } { \dim_use:N #3 }
      }
    %% Update natural height for every row
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { row[#1] / natural-height } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      { \dim_compare_p:nNn { \dim_use:N #4 } > { \l_tmpb_tl } }
      {
        \tblr_prop_gput:nxx { spec } { row[#1] / natural-height } { \dim_use:N #4 }
      }
    %% Update natural depth for every row
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { row[#1] / natural-depth } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      { \dim_compare_p:nNn { \dim_use:N #5 } > { \l_tmpb_tl } }
      {
        \tblr_prop_gput:nxx { spec } { row[#1] / natural-depth } { \dim_use:N #5 }
      }
  }

%% Build the whole table
\cs_new_eq:NN \tlbr_vbox_t:n \tex_vtop:D
\cs_new_eq:NN \tlbr_vbox_c:n \tex_vcenter:D
\cs_new_eq:NN \tlbr_vbox_b:n \tex_vbox:D
\cs_new_protected:Npn \tblr_build_whole:n #1
  {
    \tex_hbox:D
      { $ \m@th \cs:w tlbr_vbox_ #1 :n \cs_end:
          {
            \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
              {
                \tblr_prop_if_in:nxTF { spec } { hline[\l_tblr_i_tl] / style }
                  { \hrule }
                  { \hrule height ~ 0pt } % remove lineskip between two rows
                \tblr_get_row_inner_height_depth:VNN
                  \l_tblr_i_tl \l_tblr_h_dim \l_tblr_d_dim
                \tex_hbox:D
                  {
                    \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
                      {
                        \tblr_prop_if_in:nxT { spec } { vline[\l_tblr_j_tl]/style }
                          {
                            \vrule height~\l_tblr_h_dim ~ depth~\l_tblr_d_dim
                          }
                        \tblr_build_cell:NN \l_tblr_i_tl \l_tblr_j_tl
                      }
                    \tblr_prop_if_in:nxT { spec }
                      { vline[\int_eval:n {\l_tblr_col_count_int + 1}] / style }
                      {
                        \vrule height~\l_tblr_h_dim ~ depth~\l_tblr_d_dim
                      }
                  }
              }
            \tblr_prop_if_in:nxT { spec }
              { hline[\int_eval:n {\l_tblr_row_count_int + 1}] / style }
              { \hrule }
          } $
      }
  }

\cs_new_protected:Npn \tblr_build_cell:NN #1 #2
  {
    \tl_set:Nx \l_tblr_w_tl
      { \tblr_prop_item:ne { spec } { col[#2] / natural-width } }
    \tl_set:Nx \l_tblr_a_tl
      { \tblr_prop_item:ne { spec } { col[#2] / halign } }
    \skip_horizontal:n
      { \tblr_prop_item:ne { spec } { col[#2] / colsep-left } }
    \hbox_set_to_wd:Nnn \l_tblr_c_box { \l_tblr_w_tl }
      {
        \tl_if_eq:NnF \l_tblr_a_tl { left } { \hfil }
        \tblr_prop_item:ne { cell } { (#1,#2) }
        \tl_if_eq:NnT \l_tblr_a_tl { center } { \hfil }
      }
    \box_set_ht:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { spec } { row[#1] / natural-height } }
    \box_set_dp:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { spec } { row[#1] / natural-depth } }
    \box_use:N \l_tblr_c_box
    \skip_horizontal:n
      { \tblr_prop_item:ne { spec } { col[#2] / colsep-right } }
  }

%% Read from table specifications and calculate inner height of row
%% inner height = rowsep above  + natural height
%% inner depth  = natural depth + rowsep below
%% #1: the row number, #2: inner height, #3: inner depth
\cs_new_protected:Npn \tblr_get_row_inner_height_depth:nNN #1 #2 #3
  {
    \tl_set:Nx \l_tblr_a
      { \tblr_prop_item:ne { spec } { row[#1] / rowsep-above } }
    \tl_set:Nx \l_tblr_h
      { \tblr_prop_item:ne { spec } { row[#1] / natural-height } }
    \tl_set:Nx \l_tblr_d
      { \tblr_prop_item:ne { spec } { row[#1] / natural-depth } }
    \tl_set:Nx \l_tblr_b
      { \tblr_prop_item:ne { spec } { row[#1] / rowsep-below } }
    \dim_set:Nn #2 { \l_tblr_a + \l_tblr_h}
    \dim_set:Nn #3 { \l_tblr_d + \l_tblr_b }
  }
\cs_generate_variant:Nn \tblr_get_row_inner_height_depth:nNN { V }

\ExplSyntaxOff

