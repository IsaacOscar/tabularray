%%% % -*- coding: utf-8 -*-
%%% ----------------------------------------------------------------------------
%%% Tabularray: Typeset tabulars and arrays with LaTeX3
%%% Author    : Jianrui Lyu <tolvjr@163.com>
%%% Repository: https://github.com/lvjr/tabularray
%%% License   : The LaTeX Project Public License 1.3
%%% ----------------------------------------------------------------------------

\NeedsTeXFormat{LaTeX2e}
\RequirePackage{expl3}
\ProvidesExplPackage{tabularray}{2021-03-15}{2021A}
  {Typeset tabulars and arrays with LaTeX3}

%\RequirePackage{xparse}

\ExplSyntaxOn

\NewDocumentEnvironment { tblr } { O{c} m +b }
  { \buildtblr { #1 } { #2 } { #3 } } { }

\cs_generate_variant:Nn \prop_item:Nn { Ne }
\cs_generate_variant:Nn \regex_replace_all:NnN { NVN }
\cs_generate_variant:Nn \seq_map_indexed_inline:Nn { cn }
\cs_generate_variant:Nn \tl_gput_right:Nn { Ne }
\cs_generate_variant:Nn \tl_if_blank:nTF { xTF }
\prg_generate_conditional_variant:Nnn \prop_if_in:Nn { c } { T }

\tl_new:N  \l_tblr_a_tl
\tl_new:N  \l_tblr_b_tl
\tl_new:N  \l_tblr_d_tl
\tl_new:N  \l_tblr_h_tl
\tl_new:N  \l_tblr_i_tl  % for row index
\tl_new:N  \l_tblr_j_tl  % for column index
\tl_new:N  \l_tblr_w_tl
\int_new:N \l_tblr_c_int % for column number
\int_new:N \l_tblr_r_int % for row number
\dim_new:N \l_tblr_d_dim % for row depth
\dim_new:N \l_tblr_h_dim % for row height
\dim_new:N \l_tblr_w_dim % for column width
\box_new:N \l_tblr_c_box % for cell box

\seq_new:N \l_tblr_lines_seq
\int_new:N \l_tblr_row_count_int
\int_new:N \l_tblr_col_count_int
\int_new:N \g_tblr_level_int % store table nesting level
\prop_new:c { g_tblr_cell_1_prop } % store table cell text of level 1
\prop_new:c { g_tblr_spec_1_prop } % store table specification of level 1

\cs_new_protected:Npn \tblr_prop_gput:nnn #1 #2 #3
  {
    \prop_gput:cnn
      { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 } { #3 }
  }
\cs_generate_variant:Nn \tblr_prop_gput:nnn { nnV, nxn, nxx }

\cs_new:Npn \tblr_prop_item:nn #1 #2
  {
    \prop_item:cn { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } { #2 }
  }
\cs_generate_variant:Nn \tblr_prop_item:nn { ne }

\cs_new_protected:Npn \tblr_prop_if_in:nnT #1
  { \prop_if_in:cnT { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } }
\cs_new_protected:Npn \tblr_prop_if_in:nnTF #1
  { \prop_if_in:cnTF { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop } }
\prg_generate_conditional_variant:Nnn \tblr_prop_if_in:nn { nx } { T, TF }

\cs_new_protected:Npn \tblr_prop_log:n #1
  {
    \prop_log:c { g_tblr_#1_ \int_use:N \g_tblr_level_int _prop }
  }

%% Read, split and build the table
\cs_new_protected:Npn \buildtblr #1 #2 #3
  {
    \int_gincr:N \g_tblr_level_int
    \prop_gclear_new:c { g_tblr_cell_ \int_use:N \g_tblr_level_int _prop }
    \prop_gclear_new:c { g_tblr_spec_ \int_use:N \g_tblr_level_int _prop }
    \int_zero:N \l_tblr_row_count_int
    \int_zero:N \l_tblr_col_count_int
    \tl_set:Nn \l_tblr_body_tl {#3}
    %\tl_log:N \l_tblr_body_tl
    \tblr_insert_braces:N { \l_tblr_body_tl }
    \seq_set_split:NnV \l_tmpa_seq { \\ } \l_tblr_body_tl
    %\seq_log:N \l_tmpa_seq
    \seq_clear:N \l_tblr_lines_seq
    \seq_map_inline:Nn \l_tmpa_seq
      {
        \bool_lazy_or:nnTF
          { \tl_if_head_eq_meaning_p:nN { ##1 } * }
          { \tl_if_head_eq_meaning_p:nN { ##1 } [ }
          { \seq_put_right:Nn \l_tblr_lines_seq { \tblr_newline_skip ##1 } }
          { \seq_put_right:Nn \l_tblr_lines_seq { ##1 } }
      }
    \int_set:Nn \l_tblr_row_count_int { \seq_count:N \l_tblr_lines_seq }
    %\seq_log:N \l_tblr_lines_seq
    \seq_map_indexed_function:NN \l_tblr_lines_seq \tblr_split_line:nn
    \tblr_prop_log:n { cell }
    \tblr_initial_table
    \tblr_parse_column_spec:n { #2 }
    \tblr_calculate_cell_size
    \tblr_build_whole:n { #1 }
    \int_gdecr:N \g_tblr_level_int
  }

%% Insert and remove braces for nesting environments inside cells
%% These make line split and cell split workable
%% We need to replace N times for N level nestings
\regex_const:Nn \c_tblr_insert_braces_regex
  {
    \c{begin} \cB\{ (\c[^BE].*) \cE\} (.*?) \c{end} \cB\{ (\c[^BE].*) \cE\}
  }
\tl_const:Nn \c_tblr_insert_braces_tl
  {
    \c{begin} \cB\{ \cB\{ \1 \cE\} \2 \c{end} \cE\} \cB\{ \3 \cE\}
  }
\regex_const:Nn \c_tblr_remove_braces_regex
  {
    \c{begin} \cB\{ \cB\{ (.*?) \c{end} \cE\}
  }
\tl_const:Nn \c_tblr_remove_braces_tl
  {
    \c{begin} \cB\{ \1 \c{end}
  }
\cs_new_protected:Npn \tblr_insert_braces:N #1
  {
    \regex_replace_all:NVN \c_tblr_insert_braces_regex \c_tblr_insert_braces_tl #1
    \regex_replace_all:NVN \c_tblr_insert_braces_regex \c_tblr_insert_braces_tl #1
  }
\cs_new_protected:Npn \tblr_remove_braces:n #1
  {
    \tl_set:Nn \l_tmpa_tl { #1 }
    \regex_replace_all:NVN \c_tblr_remove_braces_regex \c_tblr_remove_braces_tl \l_tmpa_tl
    \regex_replace_all:NVN \c_tblr_remove_braces_regex \c_tblr_remove_braces_tl \l_tmpa_tl
  }

%% Split table line and get all the cells as a sequence
\cs_new_protected:Npn \tblr_split_line:nn #1 #2
  {
    \seq_set_split:Nnn \l_tmpa_seq { & } { #2 }
    %\seq_log:N \l_tmpa_seq
    \int_zero:N \l_tblr_c_int
    \seq_map_indexed_inline:Nn \l_tmpa_seq
      {
        \tblr_remove_braces:n { ##2 }
        \tblr_prop_gput:nnV { cell } { ( #1, ##1 ) } \l_tmpa_tl
        \int_incr:N \l_tblr_c_int
      }
    \int_compare:nT { \l_tblr_c_int > \l_tblr_col_count_int }
      {
        \int_set_eq:NN \l_tblr_col_count_int \l_tblr_c_int
      }
  }

\cs_new_protected:Npn \tblr_initial_table
  {
    \tblr_initial_table_spec
    \tblr_initial_table_command
  }

\int_new:N \rownum
\int_new:N \colnum

\prop_const_from_keyval:Nn \c_tblr_default_keyval_row_prop
  {
    rowsep-above   = 0.2em,
    rowsep-below   = 0.2em,
    valign         = top,
    natural-height = 0pt,
    natural-depth  = 0pt,
  }

\prop_const_from_keyval:Nn \c_tblr_default_keyval_col_prop
  {
    colsep-left    = 0.6em,
    colsep-right   = 0.6em,
    halign         = left,
    natural-width  = 0pt,
  }

\prop_const_from_keyval:Nn \c_tblr_default_keyval_cell_prop
  {
    natural-width  = 0pt,
    natural-height = 0pt,
    natural-depth  = 0pt,
  }

\cs_new_protected:Npn \tblr_initial_table_spec
  {
    \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
      {
        \prop_map_inline:Nn \c_tblr_default_keyval_row_prop
          {
            \tblr_prop_gput:nxn { spec } { row[\l_tblr_i_tl] / ##1 } { ##2 }
          }
        \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
          {
            \prop_map_inline:Nn \c_tblr_default_keyval_cell_prop
              {
                \tblr_prop_gput:nxn { spec }
                  { cell[\l_tblr_i_tl][\l_tblr_j_tl] / ##1 } { ##2 }
              }
          }
      }
    \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
      {
        \prop_map_inline:Nn \c_tblr_default_keyval_col_prop
          {
            \tblr_prop_gput:nxn { spec } { col[\l_tblr_j_tl] / ##1 } { ##2 }
          }
      }
  }

\NewDocumentCommand { \settblr } { m }
  { \tblr_setup:n { #1 } }

%% Setup the table
\cs_new_protected:Npn \tblr_setup:n #1
  {
    \keys_set:nn { tblr } { #1 }
  }
\cs_generate_variant:Nn \tblr_setup:n { x }

%% If the key doesn't exist, create it ahead
\cs_new_protected:Npn \tblr_keys_define_set:nn #1 #2
  {
    \keys_if_exist:nnF { tblr } { #1 }
      {
        \keys_define:nn { tblr }
          { #1 .code:n = \tblr_keys_gput:nn { #1 } { ##1 } }
      }
    \keys_set:nn { tblr } { #1 = #2 }
  }
\cs_generate_variant:Nn \tblr_keys_define_set:nn { x }

\cs_new_protected:Npn  \tblr_keys_gput:nn #1 #2
  { \tblr_prop_gput:nnn { spec } { #1 } { #2 } }

\keys_define:nn { tblr }
  {
    hline .code:n = \tblr_spec_hline:n{ #1 },
  }

%% Treat \\*[dimen] command
\NewDocumentCommand \tblr_newline_skip { s o }
  {
    \IfBooleanT { #1 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / pagebreak }
          { none }
      }
    \IfValueT { #2 }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_eval:n {\rownum - 1}] / extra-rowsep-below }
          { #2 }
      }
  }

\cs_new_protected:Npn \tblr_spec_hline:n #1
  {
    \tblr_prop_gput:nxx
      { spec }
      { hline[\int_use:N \rownum] / style }
      { solid }
  }

\cs_new_protected:Npn \tblr_initial_table_command
  {
    \cs_set_protected:Npn \hline
      { \tblr_setup:n { hline } }
  }

%% Some predefined column types and \NewColumnType command

\clist_const:Nn \c_tblr_primitive_column_type_clist { Q, | }
\tl_new:N \g_tblr_expanded_colspec_tl

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ Q } { O{} }
  {
    \int_incr:N \colnum
    \keys_set:nn { tblr-column-type-Q } { #1 }
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ Q } { O{} }
  { \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { Q[#1] } }

\keys_define:nn { tblr-column-type-Q }
  {
    l .code:n = \tblr_keys_define_set:xn
                  { col[\int_use:N \colnum] / halign } { left },
    c .code:n = \tblr_keys_define_set:xn
                  { col[\int_use:N \colnum] / halign } { center },
    r .code:n = \tblr_keys_define_set:xn
                  { col[\int_use:N \colnum] / halign } {right },
  }

\exp_args:Nc \NewDocumentCommand { tblr_primitive_column_type_ | } { O{} }
  {
    \tblr_prop_gput:nxx
      { spec }
      { vline[\int_eval:n {\colnum + 1}] / style }
      { solid }
  }
\exp_args:Nc \NewDocumentCommand { tblr_column_type_ | } { O{} }
  { \tl_gput_right:Nn \g_tblr_expanded_colspec_tl { | } }

\clist_new:N \g_tblr_defined_column_type_clist

\msg_new:nnn { tblr } { used-column-type }
  { Column ~ type ~ #1 ~ is ~ used! }

\NewDocumentCommand \NewColumnType { m O{0} o m }
  {
    \clist_gconcat:NNN \g_tmpa_clist
      \c_tblr_primitive_column_type_clist \g_tblr_defined_column_type_clist
    \clist_if_in:NnTF \g_tmpa_clist { #1 }
      {
        \msg_warning:nnn { tblr } { used-column-type } { #1 }
        \clist_log:N \g_tmpa_clist
      }
      {
        \tl_clear:N \l_tmpa_tl
        \int_compare:nNnT { #2 } > { 0 }
          {
            \IfValueTF { #3 }
              { \tl_set:Nn \l_tmpa_tl { O{#3} } }
              { \tl_set:Nn \l_tmpa_tl { m } }
            \tl_put_right:Nx \l_tmpa_tl { \prg_replicate:nn { #2 - 1 } { m } }
          }
        \exp_args:NcV \NewDocumentCommand { tblr_column_type_ #1 } \l_tmpa_tl
          { \tl_gput_right:Ne \g_tblr_expanded_colspec_tl { #4 } }
        \clist_gput_right:Nn \g_tblr_defined_column_type_clist { #1 }
      }
  }

\NewColumnType { l } { Q[l] }
\NewColumnType { c } { Q[c] }
\NewColumnType { r } { Q[r] }

\cs_new_protected:Npn \tblr_parse_column_spec:n #1
  {
    \tblr_expand_column_spec:n { #1 }
    \tblr_execute_column_spec:V \g_tblr_expanded_colspec_tl
  }

%% Expand defined column types
\cs_new_protected:Npn \tblr_expand_column_spec:n #1
  {
    \group_begin:
    \tl_gclear:N \g_tblr_expanded_colspec_tl
    \clist_gconcat:NNN \g_tmpa_clist
      \c_tblr_primitive_column_type_clist \g_tblr_defined_column_type_clist
    \clist_map_inline:Nn \g_tmpa_clist
      {
        \char_set_catcode_active:N ##1
        \char_set_active_eq:Nc ##1 { tblr_column_type_ ##1 }
      }
    \tex_scantokens:D { #1 }
    \tl_log:N \g_tblr_expanded_colspec_tl
    \group_end:
  }

%% Execute primitive column types
\cs_new_protected:Npn \tblr_execute_column_spec:n #1
  {
    \group_begin:
    \int_zero:N \colnum
    \clist_map_inline:Nn \c_tblr_primitive_column_type_clist
      {
        \char_set_catcode_active:N ##1
        \char_set_active_eq:Nc ##1 { tblr_primitive_column_type_ ##1 }
      }
    \tex_scantokens:D { #1 }
    \group_end:
  }
\cs_generate_variant:Nn \tblr_execute_column_spec:n { V }

%% Calculate the width and height of every cell
\cs_new_protected:Npn \tblr_calculate_cell_size
  {
    %% We need these two counters in executing table commands inside cells
    \int_zero:N \rownum
    \int_zero:N \colnum
    \int_step_inline:nn { \l_tblr_row_count_int }
      {
        \int_incr:N \rownum
        \int_zero:N \colnum
        \int_step_inline:nn { \l_tblr_col_count_int }
          {
            \int_incr:N \colnum
            \tblr_get_cell_size
            \tblr_update_row_col_size
          }
      }
    %% remove the last row when it has only \hline
    \tl_set:Nx \l_tblr_h_tl
      {
        \tblr_prop_item:ne { spec } { row[\l_tblr_row_count_int] / natural-height }
      }
    \tl_set:Nx \l_tblr_d_tl
      {
        \tblr_prop_item:ne { spec } { row[\l_tblr_row_count_int] / natural-depth }
      }
    \bool_lazy_and:nnT
      { \dim_compare_p:nNn { \l_tmpb_tl } = { 0pt } }
      { \dim_compare_p:nNn { \l_tmpb_tl } = { 0pt } }
      { \int_decr:N \l_tblr_row_count_int }
    \tblr_prop_log:n {spec }
  }

%% Get natural dimensions of current cell
\cs_new_protected:Npn \tblr_get_cell_size
  {
    \hbox_set:Nn \l_tblr_c_box
      {
        \tblr_prop_item:ne { cell } { (\int_use:N \rownum, \int_use:N \colnum) }
      }
    \tblr_prop_gput:nxx
      { spec }
      { cell[\int_use:N \rownum][\int_use:N \colnum] / natural-width }
      { \dim_use:N \box_wd:N \l_tblr_c_box }
    \tblr_prop_gput:nxx
      { spec }
      { cell[\int_use:N \rownum][\int_use:N \colnum] / natural-height }
      { \dim_use:N \box_ht:N \l_tblr_c_box }
    \tblr_prop_gput:nxx
      { spec }
      { cell[\int_use:N \rownum][\int_use:N \colnum] / natural-depth }
      { \dim_use:N \box_dp:N \l_tblr_c_box }
  }

%% Update natural dimensions of current row and current column
\cs_new_protected:Npn \tblr_update_row_col_size
  {
    %% Update natural width for every column
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { col[\int_use:N \colnum] / natural-width } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      {
        \dim_compare_p:nNn
          { \dim_use:N \box_wd:N \l_tblr_c_box } > { \l_tmpb_tl }
      }
      {
        \tblr_prop_gput:nxx
          { spec }
          { col[\int_use:N \colnum]/ natural-width }
          { \dim_use:N \box_wd:N \l_tblr_c_box }
      }
    %% Update natural height for every row
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { row[\int_use:N \rownum] / natural-height } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      {
        \dim_compare_p:nNn
          { \dim_use:N \box_ht:N \l_tblr_c_box } > { \l_tmpb_tl }
      }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_use:N \rownum] / natural-height }
          { \dim_use:N \box_ht:N \l_tblr_c_box }
      }
    %% Update natural depth for every row
    \tl_set:Nx \l_tmpb_tl
      { \tblr_prop_item:ne { spec } { row[\int_use:N \rownum] / natural-depth } }
    \bool_lazy_or:nnT
      { \tl_if_empty_p:N \l_tmpb_tl }
      {
        \dim_compare_p:nNn
          { \dim_use:N \box_dp:N \l_tblr_c_box } > { \l_tmpb_tl }
      }
      {
        \tblr_prop_gput:nxx
          { spec }
          { row[\int_use:N \rownum] / natural-depth }
          { \dim_use:N \box_dp:N \l_tblr_c_box }
      }
  }

%% Build the whole table
\cs_new_eq:NN \tlbr_vbox_t:n \tex_vtop:D
\cs_new_eq:NN \tlbr_vbox_c:n \tex_vcenter:D
\cs_new_eq:NN \tlbr_vbox_b:n \tex_vbox:D
\cs_new_protected:Npn \tblr_build_whole:n #1
  {
    \tex_hbox:D
      { $ \m@th \cs:w tlbr_vbox_ #1 :n \cs_end:
          {
            \int_step_variable:nNn { \l_tblr_row_count_int } \l_tblr_i_tl
              {
                \tblr_prop_if_in:nxTF { spec } { hline[\l_tblr_i_tl] / style }
                  { \hrule }
                  { \hrule height ~ 0pt } % remove lineskip between two rows
                \tblr_get_row_inner_height_depth:VNN
                  \l_tblr_i_tl \l_tblr_h_dim \l_tblr_d_dim
                \tex_hbox:D
                  {
                    \int_step_variable:nNn { \l_tblr_col_count_int } \l_tblr_j_tl
                      {
                        \tblr_prop_if_in:nxT { spec } { vline[\l_tblr_j_tl]/style }
                          {
                            \vrule height~\l_tblr_h_dim ~ depth~\l_tblr_d_dim
                          }
                        \tblr_build_cell:NN \l_tblr_i_tl \l_tblr_j_tl
                      }
                    \tblr_prop_if_in:nxT { spec }
                      { vline[\int_eval:n {\l_tblr_col_count_int + 1}] / style }
                      {
                        \vrule height~\l_tblr_h_dim ~ depth~\l_tblr_d_dim
                      }
                  }
              }
            \tblr_prop_if_in:nxT { spec }
              { hline[\int_eval:n {\l_tblr_row_count_int + 1}] / style }
              { \hrule }
          } $
      }
  }

\cs_new_protected:Npn \tblr_build_cell:NN #1 #2
  {
    \tl_set:Nx \l_tblr_w_tl
      { \tblr_prop_item:ne { spec } { col[#2] / natural-width } }
    \tl_set:Nx \l_tblr_a_tl
      { \tblr_prop_item:ne { spec } { col[#2] / halign } }
    \skip_horizontal:n
      { \tblr_prop_item:ne { spec } { col[#2] / colsep-left } }
    \hbox_set_to_wd:Nnn \l_tblr_c_box { \l_tblr_w_tl }
      {
        \tl_if_eq:NnF \l_tblr_a_tl { left } { \hfil }
        \tblr_prop_item:ne { cell } { (#1,#2) }
        \tl_if_eq:NnT \l_tblr_a_tl { center } { \hfil }
      }
    \box_set_ht:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { spec } { row[#1] / natural-height } }
    \box_set_dp:Nn \l_tblr_c_box
      { \tblr_prop_item:ne { spec } { row[#1] / natural-depth } }
    \box_use:N \l_tblr_c_box
    \skip_horizontal:n
      { \tblr_prop_item:ne { spec } { col[#2] / colsep-right } }
  }

%% Read from table specifications and calculate inner height of row
%% inner height = rowsep above  + natural height
%% inner depth  = natural depth + rowsep below
%% #1: the row number, #2: inner height, #3: inner depth
\cs_new_protected:Npn \tblr_get_row_inner_height_depth:nNN #1 #2 #3
  {
    \tl_set:Nx \l_tblr_a
      { \tblr_prop_item:ne { spec } { row[#1] / rowsep-above } }
    \tl_set:Nx \l_tblr_h
      { \tblr_prop_item:ne { spec } { row[#1] / natural-height } }
    \tl_set:Nx \l_tblr_d
      { \tblr_prop_item:ne { spec } { row[#1] / natural-depth } }
    \tl_set:Nx \l_tblr_b
      { \tblr_prop_item:ne { spec } { row[#1] / rowsep-below } }
    \dim_set:Nn #2 { \l_tblr_a + \l_tblr_h}
    \dim_set:Nn #3 { \l_tblr_d + \l_tblr_b }
  }
\cs_generate_variant:Nn \tblr_get_row_inner_height_depth:nNN { V }

\ExplSyntaxOff

